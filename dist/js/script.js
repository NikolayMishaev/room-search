/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/nouislider/dist/nouislider.js":
/*!****************************************************!*\
  !*** ./node_modules/nouislider/dist/nouislider.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function (exports) {\n  'use strict';\n\n  exports.PipsMode = void 0;\n\n  (function (PipsMode) {\n    PipsMode[\"Range\"] = \"range\";\n    PipsMode[\"Steps\"] = \"steps\";\n    PipsMode[\"Positions\"] = \"positions\";\n    PipsMode[\"Count\"] = \"count\";\n    PipsMode[\"Values\"] = \"values\";\n  })(exports.PipsMode || (exports.PipsMode = {}));\n\n  exports.PipsType = void 0;\n\n  (function (PipsType) {\n    PipsType[PipsType[\"None\"] = -1] = \"None\";\n    PipsType[PipsType[\"NoValue\"] = 0] = \"NoValue\";\n    PipsType[PipsType[\"LargeValue\"] = 1] = \"LargeValue\";\n    PipsType[PipsType[\"SmallValue\"] = 2] = \"SmallValue\";\n  })(exports.PipsType || (exports.PipsType = {})); //region Helper Methods\n\n\n  function isValidFormatter(entry) {\n    return isValidPartialFormatter(entry) && typeof entry.from === \"function\";\n  }\n\n  function isValidPartialFormatter(entry) {\n    // partial formatters only need a to function and not a from function\n    return _typeof(entry) === \"object\" && typeof entry.to === \"function\";\n  }\n\n  function removeElement(el) {\n    el.parentElement.removeChild(el);\n  }\n\n  function isSet(value) {\n    return value !== null && value !== undefined;\n  } // Bindable version\n\n\n  function preventDefault(e) {\n    e.preventDefault();\n  } // Removes duplicates from an array.\n\n\n  function unique(array) {\n    return array.filter(function (a) {\n      return !this[a] ? this[a] = true : false;\n    }, {});\n  } // Round a value to the closest 'to'.\n\n\n  function closest(value, to) {\n    return Math.round(value / to) * to;\n  } // Current position of an element relative to the document.\n\n\n  function offset(elem, orientation) {\n    var rect = elem.getBoundingClientRect();\n    var doc = elem.ownerDocument;\n    var docElem = doc.documentElement;\n    var pageOffset = getPageOffset(doc); // getBoundingClientRect contains left scroll in Chrome on Android.\n    // I haven't found a feature detection that proves this. Worst case\n    // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n\n    if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\n      pageOffset.x = 0;\n    }\n\n    return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;\n  } // Checks whether a value is numerical.\n\n\n  function isNumeric(a) {\n    return typeof a === \"number\" && !isNaN(a) && isFinite(a);\n  } // Sets a class and removes it after [duration] ms.\n\n\n  function addClassFor(element, className, duration) {\n    if (duration > 0) {\n      addClass(element, className);\n      setTimeout(function () {\n        removeClass(element, className);\n      }, duration);\n    }\n  } // Limits a value to 0 - 100\n\n\n  function limit(a) {\n    return Math.max(Math.min(a, 100), 0);\n  } // Wraps a variable as an array, if it isn't one yet.\n  // Note that an input array is returned by reference!\n\n\n  function asArray(a) {\n    return Array.isArray(a) ? a : [a];\n  } // Counts decimals\n\n\n  function countDecimals(numStr) {\n    numStr = String(numStr);\n    var pieces = numStr.split(\".\");\n    return pieces.length > 1 ? pieces[1].length : 0;\n  } // http://youmightnotneedjquery.com/#add_class\n\n\n  function addClass(el, className) {\n    if (el.classList && !/\\s/.test(className)) {\n      el.classList.add(className);\n    } else {\n      el.className += \" \" + className;\n    }\n  } // http://youmightnotneedjquery.com/#remove_class\n\n\n  function removeClass(el, className) {\n    if (el.classList && !/\\s/.test(className)) {\n      el.classList.remove(className);\n    } else {\n      el.className = el.className.replace(new RegExp(\"(^|\\\\b)\" + className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n    }\n  } // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\n\n\n  function hasClass(el, className) {\n    return el.classList ? el.classList.contains(className) : new RegExp(\"\\\\b\" + className + \"\\\\b\").test(el.className);\n  } // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\n\n\n  function getPageOffset(doc) {\n    var supportPageOffset = window.pageXOffset !== undefined;\n    var isCSS1Compat = (doc.compatMode || \"\") === \"CSS1Compat\";\n    var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;\n    var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;\n    return {\n      x: x,\n      y: y\n    };\n  } // we provide a function to compute constants instead\n  // of accessing window.* as soon as the module needs it\n  // so that we do not compute anything if not needed\n\n\n  function getActions() {\n    // Determine the events to bind. IE11 implements pointerEvents without\n    // a prefix, which breaks compatibility with the IE10 implementation.\n    return window.navigator.pointerEnabled ? {\n      start: \"pointerdown\",\n      move: \"pointermove\",\n      end: \"pointerup\"\n    } : window.navigator.msPointerEnabled ? {\n      start: \"MSPointerDown\",\n      move: \"MSPointerMove\",\n      end: \"MSPointerUp\"\n    } : {\n      start: \"mousedown touchstart\",\n      move: \"mousemove touchmove\",\n      end: \"mouseup touchend\"\n    };\n  } // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n  // Issue #785\n\n\n  function getSupportsPassive() {\n    var supportsPassive = false;\n    /* eslint-disable */\n\n    try {\n      var opts = Object.defineProperty({}, \"passive\", {\n        get: function get() {\n          supportsPassive = true;\n        }\n      }); // @ts-ignore\n\n      window.addEventListener(\"test\", null, opts);\n    } catch (e) {}\n    /* eslint-enable */\n\n\n    return supportsPassive;\n  }\n\n  function getSupportsTouchActionNone() {\n    return window.CSS && CSS.supports && CSS.supports(\"touch-action\", \"none\");\n  } //endregion\n  //region Range Calculation\n  // Determine the size of a sub-range in relation to a full range.\n\n\n  function subRangeRatio(pa, pb) {\n    return 100 / (pb - pa);\n  } // (percentage) How many percent is this value of this range?\n\n\n  function fromPercentage(range, value, startRange) {\n    return value * 100 / (range[startRange + 1] - range[startRange]);\n  } // (percentage) Where is this value on this range?\n\n\n  function toPercentage(range, value) {\n    return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);\n  } // (value) How much is this percentage on this range?\n\n\n  function isPercentage(range, value) {\n    return value * (range[1] - range[0]) / 100 + range[0];\n  }\n\n  function getJ(value, arr) {\n    var j = 1;\n\n    while (value >= arr[j]) {\n      j += 1;\n    }\n\n    return j;\n  } // (percentage) Input a value, find where, on a scale of 0-100, it applies.\n\n\n  function toStepping(xVal, xPct, value) {\n    if (value >= xVal.slice(-1)[0]) {\n      return 100;\n    }\n\n    var j = getJ(value, xVal);\n    var va = xVal[j - 1];\n    var vb = xVal[j];\n    var pa = xPct[j - 1];\n    var pb = xPct[j];\n    return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\n  } // (value) Input a percentage, find where it is on the specified range.\n\n\n  function fromStepping(xVal, xPct, value) {\n    // There is no range group that fits 100\n    if (value >= 100) {\n      return xVal.slice(-1)[0];\n    }\n\n    var j = getJ(value, xPct);\n    var va = xVal[j - 1];\n    var vb = xVal[j];\n    var pa = xPct[j - 1];\n    var pb = xPct[j];\n    return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\n  } // (percentage) Get the step that applies at a certain value.\n\n\n  function getStep(xPct, xSteps, snap, value) {\n    if (value === 100) {\n      return value;\n    }\n\n    var j = getJ(value, xPct);\n    var a = xPct[j - 1];\n    var b = xPct[j]; // If 'snap' is set, steps are used as fixed points on the slider.\n\n    if (snap) {\n      // Find the closest position, a or b.\n      if (value - a > (b - a) / 2) {\n        return b;\n      }\n\n      return a;\n    }\n\n    if (!xSteps[j - 1]) {\n      return value;\n    }\n\n    return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\n  } //endregion\n  //region Spectrum\n\n\n  var Spectrum =\n  /** @class */\n  function () {\n    function Spectrum(entry, snap, singleStep) {\n      this.xPct = [];\n      this.xVal = [];\n      this.xSteps = [];\n      this.xNumSteps = [];\n      this.xHighestCompleteStep = [];\n      this.xSteps = [singleStep || false];\n      this.xNumSteps = [false];\n      this.snap = snap;\n      var index;\n      var ordered = []; // Map the object keys to an array.\n\n      Object.keys(entry).forEach(function (index) {\n        ordered.push([asArray(entry[index]), index]);\n      }); // Sort all entries by value (numeric sort).\n\n      ordered.sort(function (a, b) {\n        return a[0][0] - b[0][0];\n      }); // Convert all entries to subranges.\n\n      for (index = 0; index < ordered.length; index++) {\n        this.handleEntryPoint(ordered[index][1], ordered[index][0]);\n      } // Store the actual step values.\n      // xSteps is sorted in the same order as xPct and xVal.\n\n\n      this.xNumSteps = this.xSteps.slice(0); // Convert all numeric steps to the percentage of the subrange they represent.\n\n      for (index = 0; index < this.xNumSteps.length; index++) {\n        this.handleStepPoint(index, this.xNumSteps[index]);\n      }\n    }\n\n    Spectrum.prototype.getDistance = function (value) {\n      var distances = [];\n\n      for (var index = 0; index < this.xNumSteps.length - 1; index++) {\n        distances[index] = fromPercentage(this.xVal, value, index);\n      }\n\n      return distances;\n    }; // Calculate the percentual distance over the whole scale of ranges.\n    // direction: 0 = backwards / 1 = forwards\n\n\n    Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {\n      var xPct_index = 0; // Calculate range where to start calculation\n\n      if (value < this.xPct[this.xPct.length - 1]) {\n        while (value > this.xPct[xPct_index + 1]) {\n          xPct_index++;\n        }\n      } else if (value === this.xPct[this.xPct.length - 1]) {\n        xPct_index = this.xPct.length - 2;\n      } // If looking backwards and the value is exactly at a range separator then look one range further\n\n\n      if (!direction && value === this.xPct[xPct_index + 1]) {\n        xPct_index++;\n      }\n\n      if (distances === null) {\n        distances = [];\n      }\n\n      var start_factor;\n      var rest_factor = 1;\n      var rest_rel_distance = distances[xPct_index];\n      var range_pct = 0;\n      var rel_range_distance = 0;\n      var abs_distance_counter = 0;\n      var range_counter = 0; // Calculate what part of the start range the value is\n\n      if (direction) {\n        start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n      } else {\n        start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n      } // Do until the complete distance across ranges is calculated\n\n\n      while (rest_rel_distance > 0) {\n        // Calculate the percentage of total range\n        range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter]; // Detect if the margin, padding or limit is larger then the current range and calculate\n\n        if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {\n          // If larger then take the percentual distance of the whole range\n          rel_range_distance = range_pct * start_factor; // Rest factor of relative percentual distance still to be calculated\n\n          rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter]; // Set start factor to 1 as for next range it does not apply.\n\n          start_factor = 1;\n        } else {\n          // If smaller or equal then take the percentual distance of the calculate percentual part of that range\n          rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor; // No rest left as the rest fits in current range\n\n          rest_factor = 0;\n        }\n\n        if (direction) {\n          abs_distance_counter = abs_distance_counter - rel_range_distance; // Limit range to first range when distance becomes outside of minimum range\n\n          if (this.xPct.length + range_counter >= 1) {\n            range_counter--;\n          }\n        } else {\n          abs_distance_counter = abs_distance_counter + rel_range_distance; // Limit range to last range when distance becomes outside of maximum range\n\n          if (this.xPct.length - range_counter >= 1) {\n            range_counter++;\n          }\n        } // Rest of relative percentual distance still to be calculated\n\n\n        rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;\n      }\n\n      return value + abs_distance_counter;\n    };\n\n    Spectrum.prototype.toStepping = function (value) {\n      value = toStepping(this.xVal, this.xPct, value);\n      return value;\n    };\n\n    Spectrum.prototype.fromStepping = function (value) {\n      return fromStepping(this.xVal, this.xPct, value);\n    };\n\n    Spectrum.prototype.getStep = function (value) {\n      value = getStep(this.xPct, this.xSteps, this.snap, value);\n      return value;\n    };\n\n    Spectrum.prototype.getDefaultStep = function (value, isDown, size) {\n      var j = getJ(value, this.xPct); // When at the top or stepping down, look at the previous sub-range\n\n      if (value === 100 || isDown && value === this.xPct[j - 1]) {\n        j = Math.max(j - 1, 1);\n      }\n\n      return (this.xVal[j] - this.xVal[j - 1]) / size;\n    };\n\n    Spectrum.prototype.getNearbySteps = function (value) {\n      var j = getJ(value, this.xPct);\n      return {\n        stepBefore: {\n          startValue: this.xVal[j - 2],\n          step: this.xNumSteps[j - 2],\n          highestStep: this.xHighestCompleteStep[j - 2]\n        },\n        thisStep: {\n          startValue: this.xVal[j - 1],\n          step: this.xNumSteps[j - 1],\n          highestStep: this.xHighestCompleteStep[j - 1]\n        },\n        stepAfter: {\n          startValue: this.xVal[j],\n          step: this.xNumSteps[j],\n          highestStep: this.xHighestCompleteStep[j]\n        }\n      };\n    };\n\n    Spectrum.prototype.countStepDecimals = function () {\n      var stepDecimals = this.xNumSteps.map(countDecimals);\n      return Math.max.apply(null, stepDecimals);\n    };\n\n    Spectrum.prototype.hasNoSize = function () {\n      return this.xVal[0] === this.xVal[this.xVal.length - 1];\n    }; // Outside testing\n\n\n    Spectrum.prototype.convert = function (value) {\n      return this.getStep(this.toStepping(value));\n    };\n\n    Spectrum.prototype.handleEntryPoint = function (index, value) {\n      var percentage; // Covert min/max syntax to 0 and 100.\n\n      if (index === \"min\") {\n        percentage = 0;\n      } else if (index === \"max\") {\n        percentage = 100;\n      } else {\n        percentage = parseFloat(index);\n      } // Check for correct input.\n\n\n      if (!isNumeric(percentage) || !isNumeric(value[0])) {\n        throw new Error(\"noUiSlider: 'range' value isn't numeric.\");\n      } // Store values.\n\n\n      this.xPct.push(percentage);\n      this.xVal.push(value[0]);\n      var value1 = Number(value[1]); // NaN will evaluate to false too, but to keep\n      // logging clear, set step explicitly. Make sure\n      // not to override the 'step' setting with false.\n\n      if (!percentage) {\n        if (!isNaN(value1)) {\n          this.xSteps[0] = value1;\n        }\n      } else {\n        this.xSteps.push(isNaN(value1) ? false : value1);\n      }\n\n      this.xHighestCompleteStep.push(0);\n    };\n\n    Spectrum.prototype.handleStepPoint = function (i, n) {\n      // Ignore 'false' stepping.\n      if (!n) {\n        return;\n      } // Step over zero-length ranges (#948);\n\n\n      if (this.xVal[i] === this.xVal[i + 1]) {\n        this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];\n        return;\n      } // Factor to range ratio\n\n\n      this.xSteps[i] = fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);\n      var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];\n      var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\n      var step = this.xVal[i] + this.xNumSteps[i] * highestStep;\n      this.xHighestCompleteStep[i] = step;\n    };\n\n    return Spectrum;\n  }(); //endregion\n  //region Options\n\n  /*\tEvery input option is tested and parsed. This will prevent\n      endless validation in internal methods. These tests are\n      structured with an item for every option available. An\n      option can be marked as required by setting the 'r' flag.\n      The testing function is provided with three arguments:\n          - The provided value for the option;\n          - A reference to the options object;\n          - The name for the option;\n       The testing function returns false when an error is detected,\n      or true when everything is OK. It can also modify the option\n      object, to make sure all values can be correctly looped elsewhere. */\n  //region Defaults\n\n\n  var defaultFormatter = {\n    to: function to(value) {\n      return value === undefined ? \"\" : value.toFixed(2);\n    },\n    from: Number\n  };\n  var cssClasses = {\n    target: \"target\",\n    base: \"base\",\n    origin: \"origin\",\n    handle: \"handle\",\n    handleLower: \"handle-lower\",\n    handleUpper: \"handle-upper\",\n    touchArea: \"touch-area\",\n    horizontal: \"horizontal\",\n    vertical: \"vertical\",\n    background: \"background\",\n    connect: \"connect\",\n    connects: \"connects\",\n    ltr: \"ltr\",\n    rtl: \"rtl\",\n    textDirectionLtr: \"txt-dir-ltr\",\n    textDirectionRtl: \"txt-dir-rtl\",\n    draggable: \"draggable\",\n    drag: \"state-drag\",\n    tap: \"state-tap\",\n    active: \"active\",\n    tooltip: \"tooltip\",\n    pips: \"pips\",\n    pipsHorizontal: \"pips-horizontal\",\n    pipsVertical: \"pips-vertical\",\n    marker: \"marker\",\n    markerHorizontal: \"marker-horizontal\",\n    markerVertical: \"marker-vertical\",\n    markerNormal: \"marker-normal\",\n    markerLarge: \"marker-large\",\n    markerSub: \"marker-sub\",\n    value: \"value\",\n    valueHorizontal: \"value-horizontal\",\n    valueVertical: \"value-vertical\",\n    valueNormal: \"value-normal\",\n    valueLarge: \"value-large\",\n    valueSub: \"value-sub\"\n  }; // Namespaces of internal event listeners\n\n  var INTERNAL_EVENT_NS = {\n    tooltips: \".__tooltips\",\n    aria: \".__aria\"\n  }; //endregion\n\n  function testStep(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'step' is not numeric.\");\n    } // The step option can still be used to set stepping\n    // for linear sliders. Overwritten if set in 'range'.\n\n\n    parsed.singleStep = entry;\n  }\n\n  function testKeyboardPageMultiplier(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'keyboardPageMultiplier' is not numeric.\");\n    }\n\n    parsed.keyboardPageMultiplier = entry;\n  }\n\n  function testKeyboardMultiplier(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'keyboardMultiplier' is not numeric.\");\n    }\n\n    parsed.keyboardMultiplier = entry;\n  }\n\n  function testKeyboardDefaultStep(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'keyboardDefaultStep' is not numeric.\");\n    }\n\n    parsed.keyboardDefaultStep = entry;\n  }\n\n  function testRange(parsed, entry) {\n    // Filter incorrect input.\n    if (_typeof(entry) !== \"object\" || Array.isArray(entry)) {\n      throw new Error(\"noUiSlider: 'range' is not an object.\");\n    } // Catch missing start or end.\n\n\n    if (entry.min === undefined || entry.max === undefined) {\n      throw new Error(\"noUiSlider: Missing 'min' or 'max' in 'range'.\");\n    }\n\n    parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);\n  }\n\n  function testStart(parsed, entry) {\n    entry = asArray(entry); // Validate input. Values aren't tested, as the public .val method\n    // will always provide a valid location.\n\n    if (!Array.isArray(entry) || !entry.length) {\n      throw new Error(\"noUiSlider: 'start' option is incorrect.\");\n    } // Store the number of handles.\n\n\n    parsed.handles = entry.length; // When the slider is initialized, the .val method will\n    // be called with the start options.\n\n    parsed.start = entry;\n  }\n\n  function testSnap(parsed, entry) {\n    if (typeof entry !== \"boolean\") {\n      throw new Error(\"noUiSlider: 'snap' option must be a boolean.\");\n    } // Enforce 100% stepping within subranges.\n\n\n    parsed.snap = entry;\n  }\n\n  function testAnimate(parsed, entry) {\n    if (typeof entry !== \"boolean\") {\n      throw new Error(\"noUiSlider: 'animate' option must be a boolean.\");\n    } // Enforce 100% stepping within subranges.\n\n\n    parsed.animate = entry;\n  }\n\n  function testAnimationDuration(parsed, entry) {\n    if (typeof entry !== \"number\") {\n      throw new Error(\"noUiSlider: 'animationDuration' option must be a number.\");\n    }\n\n    parsed.animationDuration = entry;\n  }\n\n  function testConnect(parsed, entry) {\n    var connect = [false];\n    var i; // Map legacy options\n\n    if (entry === \"lower\") {\n      entry = [true, false];\n    } else if (entry === \"upper\") {\n      entry = [false, true];\n    } // Handle boolean options\n\n\n    if (entry === true || entry === false) {\n      for (i = 1; i < parsed.handles; i++) {\n        connect.push(entry);\n      }\n\n      connect.push(false);\n    } // Reject invalid input\n    else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\n      throw new Error(\"noUiSlider: 'connect' option doesn't match handle count.\");\n    } else {\n      connect = entry;\n    }\n\n    parsed.connect = connect;\n  }\n\n  function testOrientation(parsed, entry) {\n    // Set orientation to an a numerical value for easy\n    // array selection.\n    switch (entry) {\n      case \"horizontal\":\n        parsed.ort = 0;\n        break;\n\n      case \"vertical\":\n        parsed.ort = 1;\n        break;\n\n      default:\n        throw new Error(\"noUiSlider: 'orientation' option is invalid.\");\n    }\n  }\n\n  function testMargin(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'margin' option must be numeric.\");\n    } // Issue #582\n\n\n    if (entry === 0) {\n      return;\n    }\n\n    parsed.margin = parsed.spectrum.getDistance(entry);\n  }\n\n  function testLimit(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error(\"noUiSlider: 'limit' option must be numeric.\");\n    }\n\n    parsed.limit = parsed.spectrum.getDistance(entry);\n\n    if (!parsed.limit || parsed.handles < 2) {\n      throw new Error(\"noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.\");\n    }\n  }\n\n  function testPadding(parsed, entry) {\n    var index;\n\n    if (!isNumeric(entry) && !Array.isArray(entry)) {\n      throw new Error(\"noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.\");\n    }\n\n    if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\n      throw new Error(\"noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.\");\n    }\n\n    if (entry === 0) {\n      return;\n    }\n\n    if (!Array.isArray(entry)) {\n      entry = [entry, entry];\n    } // 'getDistance' returns false for invalid values.\n\n\n    parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];\n\n    for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {\n      // last \"range\" can't contain step size as it is purely an endpoint.\n      if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {\n        throw new Error(\"noUiSlider: 'padding' option must be a positive number(s).\");\n      }\n    }\n\n    var totalPadding = entry[0] + entry[1];\n    var firstValue = parsed.spectrum.xVal[0];\n    var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];\n\n    if (totalPadding / (lastValue - firstValue) > 1) {\n      throw new Error(\"noUiSlider: 'padding' option must not exceed 100% of the range.\");\n    }\n  }\n\n  function testDirection(parsed, entry) {\n    // Set direction as a numerical value for easy parsing.\n    // Invert connection for RTL sliders, so that the proper\n    // handles get the connect/background classes.\n    switch (entry) {\n      case \"ltr\":\n        parsed.dir = 0;\n        break;\n\n      case \"rtl\":\n        parsed.dir = 1;\n        break;\n\n      default:\n        throw new Error(\"noUiSlider: 'direction' option was not recognized.\");\n    }\n  }\n\n  function testBehaviour(parsed, entry) {\n    // Make sure the input is a string.\n    if (typeof entry !== \"string\") {\n      throw new Error(\"noUiSlider: 'behaviour' must be a string containing options.\");\n    } // Check if the string contains any keywords.\n    // None are required.\n\n\n    var tap = entry.indexOf(\"tap\") >= 0;\n    var drag = entry.indexOf(\"drag\") >= 0;\n    var fixed = entry.indexOf(\"fixed\") >= 0;\n    var snap = entry.indexOf(\"snap\") >= 0;\n    var hover = entry.indexOf(\"hover\") >= 0;\n    var unconstrained = entry.indexOf(\"unconstrained\") >= 0;\n    var dragAll = entry.indexOf(\"drag-all\") >= 0;\n    var smoothSteps = entry.indexOf(\"smooth-steps\") >= 0;\n\n    if (fixed) {\n      if (parsed.handles !== 2) {\n        throw new Error(\"noUiSlider: 'fixed' behaviour must be used with 2 handles\");\n      } // Use margin to enforce fixed state\n\n\n      testMargin(parsed, parsed.start[1] - parsed.start[0]);\n    }\n\n    if (unconstrained && (parsed.margin || parsed.limit)) {\n      throw new Error(\"noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit\");\n    }\n\n    parsed.events = {\n      tap: tap || snap,\n      drag: drag,\n      dragAll: dragAll,\n      smoothSteps: smoothSteps,\n      fixed: fixed,\n      snap: snap,\n      hover: hover,\n      unconstrained: unconstrained\n    };\n  }\n\n  function testTooltips(parsed, entry) {\n    if (entry === false) {\n      return;\n    }\n\n    if (entry === true || isValidPartialFormatter(entry)) {\n      parsed.tooltips = [];\n\n      for (var i = 0; i < parsed.handles; i++) {\n        parsed.tooltips.push(entry);\n      }\n    } else {\n      entry = asArray(entry);\n\n      if (entry.length !== parsed.handles) {\n        throw new Error(\"noUiSlider: must pass a formatter for all handles.\");\n      }\n\n      entry.forEach(function (formatter) {\n        if (typeof formatter !== \"boolean\" && !isValidPartialFormatter(formatter)) {\n          throw new Error(\"noUiSlider: 'tooltips' must be passed a formatter or 'false'.\");\n        }\n      });\n      parsed.tooltips = entry;\n    }\n  }\n\n  function testHandleAttributes(parsed, entry) {\n    if (entry.length !== parsed.handles) {\n      throw new Error(\"noUiSlider: must pass a attributes for all handles.\");\n    }\n\n    parsed.handleAttributes = entry;\n  }\n\n  function testAriaFormat(parsed, entry) {\n    if (!isValidPartialFormatter(entry)) {\n      throw new Error(\"noUiSlider: 'ariaFormat' requires 'to' method.\");\n    }\n\n    parsed.ariaFormat = entry;\n  }\n\n  function testFormat(parsed, entry) {\n    if (!isValidFormatter(entry)) {\n      throw new Error(\"noUiSlider: 'format' requires 'to' and 'from' methods.\");\n    }\n\n    parsed.format = entry;\n  }\n\n  function testKeyboardSupport(parsed, entry) {\n    if (typeof entry !== \"boolean\") {\n      throw new Error(\"noUiSlider: 'keyboardSupport' option must be a boolean.\");\n    }\n\n    parsed.keyboardSupport = entry;\n  }\n\n  function testDocumentElement(parsed, entry) {\n    // This is an advanced option. Passed values are used without validation.\n    parsed.documentElement = entry;\n  }\n\n  function testCssPrefix(parsed, entry) {\n    if (typeof entry !== \"string\" && entry !== false) {\n      throw new Error(\"noUiSlider: 'cssPrefix' must be a string or `false`.\");\n    }\n\n    parsed.cssPrefix = entry;\n  }\n\n  function testCssClasses(parsed, entry) {\n    if (_typeof(entry) !== \"object\") {\n      throw new Error(\"noUiSlider: 'cssClasses' must be an object.\");\n    }\n\n    if (typeof parsed.cssPrefix === \"string\") {\n      parsed.cssClasses = {};\n      Object.keys(entry).forEach(function (key) {\n        parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\n      });\n    } else {\n      parsed.cssClasses = entry;\n    }\n  } // Test all developer settings and parse to assumption-safe values.\n\n\n  function testOptions(options) {\n    // To prove a fix for #537, freeze options here.\n    // If the object is modified, an error will be thrown.\n    // Object.freeze(options);\n    var parsed = {\n      margin: null,\n      limit: null,\n      padding: null,\n      animate: true,\n      animationDuration: 300,\n      ariaFormat: defaultFormatter,\n      format: defaultFormatter\n    }; // Tests are executed in the order they are presented here.\n\n    var tests = {\n      step: {\n        r: false,\n        t: testStep\n      },\n      keyboardPageMultiplier: {\n        r: false,\n        t: testKeyboardPageMultiplier\n      },\n      keyboardMultiplier: {\n        r: false,\n        t: testKeyboardMultiplier\n      },\n      keyboardDefaultStep: {\n        r: false,\n        t: testKeyboardDefaultStep\n      },\n      start: {\n        r: true,\n        t: testStart\n      },\n      connect: {\n        r: true,\n        t: testConnect\n      },\n      direction: {\n        r: true,\n        t: testDirection\n      },\n      snap: {\n        r: false,\n        t: testSnap\n      },\n      animate: {\n        r: false,\n        t: testAnimate\n      },\n      animationDuration: {\n        r: false,\n        t: testAnimationDuration\n      },\n      range: {\n        r: true,\n        t: testRange\n      },\n      orientation: {\n        r: false,\n        t: testOrientation\n      },\n      margin: {\n        r: false,\n        t: testMargin\n      },\n      limit: {\n        r: false,\n        t: testLimit\n      },\n      padding: {\n        r: false,\n        t: testPadding\n      },\n      behaviour: {\n        r: true,\n        t: testBehaviour\n      },\n      ariaFormat: {\n        r: false,\n        t: testAriaFormat\n      },\n      format: {\n        r: false,\n        t: testFormat\n      },\n      tooltips: {\n        r: false,\n        t: testTooltips\n      },\n      keyboardSupport: {\n        r: true,\n        t: testKeyboardSupport\n      },\n      documentElement: {\n        r: false,\n        t: testDocumentElement\n      },\n      cssPrefix: {\n        r: true,\n        t: testCssPrefix\n      },\n      cssClasses: {\n        r: true,\n        t: testCssClasses\n      },\n      handleAttributes: {\n        r: false,\n        t: testHandleAttributes\n      }\n    };\n    var defaults = {\n      connect: false,\n      direction: \"ltr\",\n      behaviour: \"tap\",\n      orientation: \"horizontal\",\n      keyboardSupport: true,\n      cssPrefix: \"noUi-\",\n      cssClasses: cssClasses,\n      keyboardPageMultiplier: 5,\n      keyboardMultiplier: 1,\n      keyboardDefaultStep: 10\n    }; // AriaFormat defaults to regular format, if any.\n\n    if (options.format && !options.ariaFormat) {\n      options.ariaFormat = options.format;\n    } // Run all options through a testing mechanism to ensure correct\n    // input. It should be noted that options might get modified to\n    // be handled properly. E.g. wrapping integers in arrays.\n\n\n    Object.keys(tests).forEach(function (name) {\n      // If the option isn't set, but it is required, throw an error.\n      if (!isSet(options[name]) && defaults[name] === undefined) {\n        if (tests[name].r) {\n          throw new Error(\"noUiSlider: '\" + name + \"' is required.\");\n        }\n\n        return;\n      }\n\n      tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\n    }); // Forward pips options\n\n    parsed.pips = options.pips; // All recent browsers accept unprefixed transform.\n    // We need -ms- for IE9 and -webkit- for older Android;\n    // Assume use of -webkit- if unprefixed and -ms- are not supported.\n    // https://caniuse.com/#feat=transforms2d\n\n    var d = document.createElement(\"div\");\n    var msPrefix = d.style.msTransform !== undefined;\n    var noPrefix = d.style.transform !== undefined;\n    parsed.transformRule = noPrefix ? \"transform\" : msPrefix ? \"msTransform\" : \"webkitTransform\"; // Pips don't move, so we can place them using left/top.\n\n    var styles = [[\"left\", \"top\"], [\"right\", \"bottom\"]];\n    parsed.style = styles[parsed.dir][parsed.ort];\n    return parsed;\n  } //endregion\n\n\n  function scope(target, options, originalOptions) {\n    var actions = getActions();\n    var supportsTouchActionNone = getSupportsTouchActionNone();\n    var supportsPassive = supportsTouchActionNone && getSupportsPassive(); // All variables local to 'scope' are prefixed with 'scope_'\n    // Slider DOM Nodes\n\n    var scope_Target = target;\n    var scope_Base;\n    var scope_Handles;\n    var scope_Connects;\n    var scope_Pips;\n    var scope_Tooltips; // Slider state values\n\n    var scope_Spectrum = options.spectrum;\n    var scope_Values = [];\n    var scope_Locations = [];\n    var scope_HandleNumbers = [];\n    var scope_ActiveHandlesCount = 0;\n    var scope_Events = {}; // Document Nodes\n\n    var scope_Document = target.ownerDocument;\n    var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\n    var scope_Body = scope_Document.body; // For horizontal sliders in standard ltr documents,\n    // make .noUi-origin overflow to the left so the document doesn't scroll.\n\n    var scope_DirOffset = scope_Document.dir === \"rtl\" || options.ort === 1 ? 0 : 100; // Creates a node, adds it to target, returns the new node.\n\n    function addNodeTo(addTarget, className) {\n      var div = scope_Document.createElement(\"div\");\n\n      if (className) {\n        addClass(div, className);\n      }\n\n      addTarget.appendChild(div);\n      return div;\n    } // Append a origin to the base\n\n\n    function addOrigin(base, handleNumber) {\n      var origin = addNodeTo(base, options.cssClasses.origin);\n      var handle = addNodeTo(origin, options.cssClasses.handle);\n      addNodeTo(handle, options.cssClasses.touchArea);\n      handle.setAttribute(\"data-handle\", String(handleNumber));\n\n      if (options.keyboardSupport) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\n        // 0 = focusable and reachable\n        handle.setAttribute(\"tabindex\", \"0\");\n        handle.addEventListener(\"keydown\", function (event) {\n          return eventKeydown(event, handleNumber);\n        });\n      }\n\n      if (options.handleAttributes !== undefined) {\n        var attributes_1 = options.handleAttributes[handleNumber];\n        Object.keys(attributes_1).forEach(function (attribute) {\n          handle.setAttribute(attribute, attributes_1[attribute]);\n        });\n      }\n\n      handle.setAttribute(\"role\", \"slider\");\n      handle.setAttribute(\"aria-orientation\", options.ort ? \"vertical\" : \"horizontal\");\n\n      if (handleNumber === 0) {\n        addClass(handle, options.cssClasses.handleLower);\n      } else if (handleNumber === options.handles - 1) {\n        addClass(handle, options.cssClasses.handleUpper);\n      }\n\n      return origin;\n    } // Insert nodes for connect elements\n\n\n    function addConnect(base, add) {\n      if (!add) {\n        return false;\n      }\n\n      return addNodeTo(base, options.cssClasses.connect);\n    } // Add handles to the slider base.\n\n\n    function addElements(connectOptions, base) {\n      var connectBase = addNodeTo(base, options.cssClasses.connects);\n      scope_Handles = [];\n      scope_Connects = [];\n      scope_Connects.push(addConnect(connectBase, connectOptions[0])); // [::::O====O====O====]\n      // connectOptions = [0, 1, 1, 1]\n\n      for (var i = 0; i < options.handles; i++) {\n        // Keep a list of all added handles.\n        scope_Handles.push(addOrigin(base, i));\n        scope_HandleNumbers[i] = i;\n        scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\n      }\n    } // Initialize a single slider.\n\n\n    function addSlider(addTarget) {\n      // Apply classes and data to the target.\n      addClass(addTarget, options.cssClasses.target);\n\n      if (options.dir === 0) {\n        addClass(addTarget, options.cssClasses.ltr);\n      } else {\n        addClass(addTarget, options.cssClasses.rtl);\n      }\n\n      if (options.ort === 0) {\n        addClass(addTarget, options.cssClasses.horizontal);\n      } else {\n        addClass(addTarget, options.cssClasses.vertical);\n      }\n\n      var textDirection = getComputedStyle(addTarget).direction;\n\n      if (textDirection === \"rtl\") {\n        addClass(addTarget, options.cssClasses.textDirectionRtl);\n      } else {\n        addClass(addTarget, options.cssClasses.textDirectionLtr);\n      }\n\n      return addNodeTo(addTarget, options.cssClasses.base);\n    }\n\n    function addTooltip(handle, handleNumber) {\n      if (!options.tooltips || !options.tooltips[handleNumber]) {\n        return false;\n      }\n\n      return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\n    }\n\n    function isSliderDisabled() {\n      return scope_Target.hasAttribute(\"disabled\");\n    } // Disable the slider dragging if any handle is disabled\n\n\n    function isHandleDisabled(handleNumber) {\n      var handleOrigin = scope_Handles[handleNumber];\n      return handleOrigin.hasAttribute(\"disabled\");\n    }\n\n    function removeTooltips() {\n      if (scope_Tooltips) {\n        removeEvent(\"update\" + INTERNAL_EVENT_NS.tooltips);\n        scope_Tooltips.forEach(function (tooltip) {\n          if (tooltip) {\n            removeElement(tooltip);\n          }\n        });\n        scope_Tooltips = null;\n      }\n    } // The tooltips option is a shorthand for using the 'update' event.\n\n\n    function tooltips() {\n      removeTooltips(); // Tooltips are added with options.tooltips in original order.\n\n      scope_Tooltips = scope_Handles.map(addTooltip);\n      bindEvent(\"update\" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {\n        if (!scope_Tooltips || !options.tooltips) {\n          return;\n        }\n\n        if (scope_Tooltips[handleNumber] === false) {\n          return;\n        }\n\n        var formattedValue = values[handleNumber];\n\n        if (options.tooltips[handleNumber] !== true) {\n          formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\n        }\n\n        scope_Tooltips[handleNumber].innerHTML = formattedValue;\n      });\n    }\n\n    function aria() {\n      removeEvent(\"update\" + INTERNAL_EVENT_NS.aria);\n      bindEvent(\"update\" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {\n        // Update Aria Values for all handles, as a change in one changes min and max values for the next.\n        scope_HandleNumbers.forEach(function (index) {\n          var handle = scope_Handles[index];\n          var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\n          var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\n          var now = positions[index]; // Formatted value for display\n\n          var text = String(options.ariaFormat.to(unencoded[index])); // Map to slider range values\n\n          min = scope_Spectrum.fromStepping(min).toFixed(1);\n          max = scope_Spectrum.fromStepping(max).toFixed(1);\n          now = scope_Spectrum.fromStepping(now).toFixed(1);\n          handle.children[0].setAttribute(\"aria-valuemin\", min);\n          handle.children[0].setAttribute(\"aria-valuemax\", max);\n          handle.children[0].setAttribute(\"aria-valuenow\", now);\n          handle.children[0].setAttribute(\"aria-valuetext\", text);\n        });\n      });\n    }\n\n    function getGroup(pips) {\n      // Use the range.\n      if (pips.mode === exports.PipsMode.Range || pips.mode === exports.PipsMode.Steps) {\n        return scope_Spectrum.xVal;\n      }\n\n      if (pips.mode === exports.PipsMode.Count) {\n        if (pips.values < 2) {\n          throw new Error(\"noUiSlider: 'values' (>= 2) required for mode 'count'.\");\n        } // Divide 0 - 100 in 'count' parts.\n\n\n        var interval = pips.values - 1;\n        var spread = 100 / interval;\n        var values = []; // List these parts and have them handled as 'positions'.\n\n        while (interval--) {\n          values[interval] = interval * spread;\n        }\n\n        values.push(100);\n        return mapToRange(values, pips.stepped);\n      }\n\n      if (pips.mode === exports.PipsMode.Positions) {\n        // Map all percentages to on-range values.\n        return mapToRange(pips.values, pips.stepped);\n      }\n\n      if (pips.mode === exports.PipsMode.Values) {\n        // If the value must be stepped, it needs to be converted to a percentage first.\n        if (pips.stepped) {\n          return pips.values.map(function (value) {\n            // Convert to percentage, apply step, return to value.\n            return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\n          });\n        } // Otherwise, we can simply use the values.\n\n\n        return pips.values;\n      }\n\n      return []; // pips.mode = never\n    }\n\n    function mapToRange(values, stepped) {\n      return values.map(function (value) {\n        return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\n      });\n    }\n\n    function generateSpread(pips) {\n      function safeIncrement(value, increment) {\n        // Avoid floating point variance by dropping the smallest decimal places.\n        return Number((value + increment).toFixed(7));\n      }\n\n      var group = getGroup(pips);\n      var indexes = {};\n      var firstInRange = scope_Spectrum.xVal[0];\n      var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\n      var ignoreFirst = false;\n      var ignoreLast = false;\n      var prevPct = 0; // Create a copy of the group, sort it and filter away all duplicates.\n\n      group = unique(group.slice().sort(function (a, b) {\n        return a - b;\n      })); // Make sure the range starts with the first element.\n\n      if (group[0] !== firstInRange) {\n        group.unshift(firstInRange);\n        ignoreFirst = true;\n      } // Likewise for the last one.\n\n\n      if (group[group.length - 1] !== lastInRange) {\n        group.push(lastInRange);\n        ignoreLast = true;\n      }\n\n      group.forEach(function (current, index) {\n        // Get the current step and the lower + upper positions.\n        var step;\n        var i;\n        var q;\n        var low = current;\n        var high = group[index + 1];\n        var newPct;\n        var pctDifference;\n        var pctPos;\n        var type;\n        var steps;\n        var realSteps;\n        var stepSize;\n        var isSteps = pips.mode === exports.PipsMode.Steps; // When using 'steps' mode, use the provided steps.\n        // Otherwise, we'll step on to the next subrange.\n\n        if (isSteps) {\n          step = scope_Spectrum.xNumSteps[index];\n        } // Default to a 'full' step.\n\n\n        if (!step) {\n          step = high - low;\n        } // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)\n\n\n        if (high === undefined) {\n          high = low;\n        } // Make sure step isn't 0, which would cause an infinite loop (#654)\n\n\n        step = Math.max(step, 0.0000001); // Find all steps in the subrange.\n\n        for (i = low; i <= high; i = safeIncrement(i, step)) {\n          // Get the percentage value for the current step,\n          // calculate the size for the subrange.\n          newPct = scope_Spectrum.toStepping(i);\n          pctDifference = newPct - prevPct;\n          steps = pctDifference / (pips.density || 1);\n          realSteps = Math.round(steps); // This ratio represents the amount of percentage-space a point indicates.\n          // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\n          // Round the percentage offset to an even number, then divide by two\n          // to spread the offset on both sides of the range.\n\n          stepSize = pctDifference / realSteps; // Divide all points evenly, adding the correct number to this subrange.\n          // Run up to <= so that 100% gets a point, event if ignoreLast is set.\n\n          for (q = 1; q <= realSteps; q += 1) {\n            // The ratio between the rounded value and the actual size might be ~1% off.\n            // Correct the percentage offset by the number of points\n            // per subrange. density = 1 will result in 100 points on the\n            // full range, 2 for 50, 4 for 25, etc.\n            pctPos = prevPct + q * stepSize;\n            indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\n          } // Determine the point type.\n\n\n          type = group.indexOf(i) > -1 ? exports.PipsType.LargeValue : isSteps ? exports.PipsType.SmallValue : exports.PipsType.NoValue; // Enforce the 'ignoreFirst' option by overwriting the type for 0.\n\n          if (!index && ignoreFirst && i !== high) {\n            type = 0;\n          }\n\n          if (!(i === high && ignoreLast)) {\n            // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\n            indexes[newPct.toFixed(5)] = [i, type];\n          } // Update the percentage count.\n\n\n          prevPct = newPct;\n        }\n      });\n      return indexes;\n    }\n\n    function addMarking(spread, filterFunc, formatter) {\n      var _a, _b;\n\n      var element = scope_Document.createElement(\"div\");\n      var valueSizeClasses = (_a = {}, _a[exports.PipsType.None] = \"\", _a[exports.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports.PipsType.SmallValue] = options.cssClasses.valueSub, _a);\n      var markerSizeClasses = (_b = {}, _b[exports.PipsType.None] = \"\", _b[exports.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports.PipsType.SmallValue] = options.cssClasses.markerSub, _b);\n      var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\n      var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\n      addClass(element, options.cssClasses.pips);\n      addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\n\n      function getClasses(type, source) {\n        var a = source === options.cssClasses.value;\n        var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\n        var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\n        return source + \" \" + orientationClasses[options.ort] + \" \" + sizeClasses[type];\n      }\n\n      function addSpread(offset, value, type) {\n        // Apply the filter function, if it is set.\n        type = filterFunc ? filterFunc(value, type) : type;\n\n        if (type === exports.PipsType.None) {\n          return;\n        } // Add a marker for every point\n\n\n        var node = addNodeTo(element, false);\n        node.className = getClasses(type, options.cssClasses.marker);\n        node.style[options.style] = offset + \"%\"; // Values are only appended for points marked '1' or '2'.\n\n        if (type > exports.PipsType.NoValue) {\n          node = addNodeTo(element, false);\n          node.className = getClasses(type, options.cssClasses.value);\n          node.setAttribute(\"data-value\", String(value));\n          node.style[options.style] = offset + \"%\";\n          node.innerHTML = String(formatter.to(value));\n        }\n      } // Append all points.\n\n\n      Object.keys(spread).forEach(function (offset) {\n        addSpread(offset, spread[offset][0], spread[offset][1]);\n      });\n      return element;\n    }\n\n    function removePips() {\n      if (scope_Pips) {\n        removeElement(scope_Pips);\n        scope_Pips = null;\n      }\n    }\n\n    function pips(pips) {\n      // Fix #669\n      removePips();\n      var spread = generateSpread(pips);\n      var filter = pips.filter;\n      var format = pips.format || {\n        to: function to(value) {\n          return String(Math.round(value));\n        }\n      };\n      scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\n      return scope_Pips;\n    } // Shorthand for base dimensions.\n\n\n    function baseSize() {\n      var rect = scope_Base.getBoundingClientRect();\n      var alt = \"offset\" + [\"Width\", \"Height\"][options.ort];\n      return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\n    } // Handler for attaching events trough a proxy.\n\n\n    function attachEvent(events, element, callback, data) {\n      // This function can be used to 'filter' events to the slider.\n      // element is a node, not a nodeList\n      var method = function method(event) {\n        var e = fixEvent(event, data.pageOffset, data.target || element); // fixEvent returns false if this event has a different target\n        // when handling (multi-) touch events;\n\n        if (!e) {\n          return false;\n        } // doNotReject is passed by all end events to make sure released touches\n        // are not rejected, leaving the slider \"stuck\" to the cursor;\n\n\n        if (isSliderDisabled() && !data.doNotReject) {\n          return false;\n        } // Stop if an active 'tap' transition is taking place.\n\n\n        if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\n          return false;\n        } // Ignore right or middle clicks on start #454\n\n\n        if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\n          return false;\n        } // Ignore right or middle clicks on start #454\n\n\n        if (data.hover && e.buttons) {\n          return false;\n        } // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.\n        // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support\n        // touch-action: manipulation, but that allows panning, which breaks\n        // sliders after zooming/on non-responsive pages.\n        // See: https://bugs.webkit.org/show_bug.cgi?id=133112\n\n\n        if (!supportsPassive) {\n          e.preventDefault();\n        }\n\n        e.calcPoint = e.points[options.ort]; // Call the event handler with the event [ and additional data ].\n\n        callback(e, data);\n        return;\n      };\n\n      var methods = []; // Bind a closure on the target for every event type.\n\n      events.split(\" \").forEach(function (eventName) {\n        element.addEventListener(eventName, method, supportsPassive ? {\n          passive: true\n        } : false);\n        methods.push([eventName, method]);\n      });\n      return methods;\n    } // Provide a clean event with standardized offset values.\n\n\n    function fixEvent(e, pageOffset, eventTarget) {\n      // Filter the event to register the type, which can be\n      // touch, mouse or pointer. Offset changes need to be\n      // made on an event specific basis.\n      var touch = e.type.indexOf(\"touch\") === 0;\n      var mouse = e.type.indexOf(\"mouse\") === 0;\n      var pointer = e.type.indexOf(\"pointer\") === 0;\n      var x = 0;\n      var y = 0; // IE10 implemented pointer events with a prefix;\n\n      if (e.type.indexOf(\"MSPointer\") === 0) {\n        pointer = true;\n      } // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with\n      // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore\n      // events that have no touches or buttons associated with them. (#1057, #1079, #1095)\n\n\n      if (e.type === \"mousedown\" && !e.buttons && !e.touches) {\n        return false;\n      } // The only thing one handle should be concerned about is the touches that originated on top of it.\n\n\n      if (touch) {\n        // Returns true if a touch originated on the target.\n        var isTouchOnTarget = function isTouchOnTarget(checkTouch) {\n          var target = checkTouch.target;\n          return target === eventTarget || eventTarget.contains(target) || e.composed && e.composedPath().shift() === eventTarget;\n        }; // In the case of touchstart events, we need to make sure there is still no more than one\n        // touch on the target so we look amongst all touches.\n\n\n        if (e.type === \"touchstart\") {\n          var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget); // Do not support more than one touch per handle.\n\n          if (targetTouches.length > 1) {\n            return false;\n          }\n\n          x = targetTouches[0].pageX;\n          y = targetTouches[0].pageY;\n        } else {\n          // In the other cases, find on changedTouches is enough.\n          var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget); // Cancel if the target touch has not moved.\n\n          if (!targetTouch) {\n            return false;\n          }\n\n          x = targetTouch.pageX;\n          y = targetTouch.pageY;\n        }\n      }\n\n      pageOffset = pageOffset || getPageOffset(scope_Document);\n\n      if (mouse || pointer) {\n        x = e.clientX + pageOffset.x;\n        y = e.clientY + pageOffset.y;\n      }\n\n      e.pageOffset = pageOffset;\n      e.points = [x, y];\n      e.cursor = mouse || pointer; // Fix #435\n\n      return e;\n    } // Translate a coordinate in the document to a percentage on the slider\n\n\n    function calcPointToPercentage(calcPoint) {\n      var location = calcPoint - offset(scope_Base, options.ort);\n      var proposal = location * 100 / baseSize(); // Clamp proposal between 0% and 100%\n      // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\n      // are used (e.g. contained handles feature)\n\n      proposal = limit(proposal);\n      return options.dir ? 100 - proposal : proposal;\n    } // Find handle closest to a certain percentage on the slider\n\n\n    function getClosestHandle(clickedPosition) {\n      var smallestDifference = 100;\n      var handleNumber = false;\n      scope_Handles.forEach(function (handle, index) {\n        // Disabled handles are ignored\n        if (isHandleDisabled(index)) {\n          return;\n        }\n\n        var handlePosition = scope_Locations[index];\n        var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition); // Initial state\n\n        var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100; // Difference with this handle is smaller than the previously checked handle\n\n        var isCloser = differenceWithThisHandle < smallestDifference;\n        var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;\n\n        if (isCloser || isCloserAfter || clickAtEdge) {\n          handleNumber = index;\n          smallestDifference = differenceWithThisHandle;\n        }\n      });\n      return handleNumber;\n    } // Fire 'end' when a mouse or pen leaves the document.\n\n\n    function documentLeave(event, data) {\n      if (event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null) {\n        eventEnd(event, data);\n      }\n    } // Handle movement on document for handle and range drag.\n\n\n    function eventMove(event, data) {\n      // Fix #498\n      // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\n      // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\n      // IE9 has .buttons and .which zero on mousemove.\n      // Firefox breaks the spec MDN defines.\n      if (navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\n        return eventEnd(event, data);\n      } // Check if we are moving up or down\n\n\n      var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint); // Convert the movement into a percentage of the slider width/height\n\n      var proposal = movement * 100 / data.baseSize;\n      moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);\n    } // Unbind move events on document, call callbacks.\n\n\n    function eventEnd(event, data) {\n      // The handle is no longer active, so remove the class.\n      if (data.handle) {\n        removeClass(data.handle, options.cssClasses.active);\n        scope_ActiveHandlesCount -= 1;\n      } // Unbind the move and end events, which are added on 'start'.\n\n\n      data.listeners.forEach(function (c) {\n        scope_DocumentElement.removeEventListener(c[0], c[1]);\n      });\n\n      if (scope_ActiveHandlesCount === 0) {\n        // Remove dragging class.\n        removeClass(scope_Target, options.cssClasses.drag);\n        setZindex(); // Remove cursor styles and text-selection events bound to the body.\n\n        if (event.cursor) {\n          scope_Body.style.cursor = \"\";\n          scope_Body.removeEventListener(\"selectstart\", preventDefault);\n        }\n      }\n\n      if (options.events.smoothSteps) {\n        data.handleNumbers.forEach(function (handleNumber) {\n          setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);\n        });\n        data.handleNumbers.forEach(function (handleNumber) {\n          fireEvent(\"update\", handleNumber);\n        });\n      }\n\n      data.handleNumbers.forEach(function (handleNumber) {\n        fireEvent(\"change\", handleNumber);\n        fireEvent(\"set\", handleNumber);\n        fireEvent(\"end\", handleNumber);\n      });\n    } // Bind move events on document.\n\n\n    function eventStart(event, data) {\n      // Ignore event if any handle is disabled\n      if (data.handleNumbers.some(isHandleDisabled)) {\n        return;\n      }\n\n      var handle;\n\n      if (data.handleNumbers.length === 1) {\n        var handleOrigin = scope_Handles[data.handleNumbers[0]];\n        handle = handleOrigin.children[0];\n        scope_ActiveHandlesCount += 1; // Mark the handle as 'active' so it can be styled.\n\n        addClass(handle, options.cssClasses.active);\n      } // A drag should never propagate up to the 'tap' event.\n\n\n      event.stopPropagation(); // Record the event listeners.\n\n      var listeners = []; // Attach the move and end events.\n\n      var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\n        // The event target has changed so we need to propagate the original one so that we keep\n        // relying on it to extract target touches.\n        target: event.target,\n        handle: handle,\n        connect: data.connect,\n        listeners: listeners,\n        startCalcPoint: event.calcPoint,\n        baseSize: baseSize(),\n        pageOffset: event.pageOffset,\n        handleNumbers: data.handleNumbers,\n        buttonsProperty: event.buttons,\n        locations: scope_Locations.slice()\n      });\n      var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\n        target: event.target,\n        handle: handle,\n        listeners: listeners,\n        doNotReject: true,\n        handleNumbers: data.handleNumbers\n      });\n      var outEvent = attachEvent(\"mouseout\", scope_DocumentElement, documentLeave, {\n        target: event.target,\n        handle: handle,\n        listeners: listeners,\n        doNotReject: true,\n        handleNumbers: data.handleNumbers\n      }); // We want to make sure we pushed the listeners in the listener list rather than creating\n      // a new one as it has already been passed to the event handlers.\n\n      listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)); // Text selection isn't an issue on touch devices,\n      // so adding cursor styles can be skipped.\n\n      if (event.cursor) {\n        // Prevent the 'I' cursor and extend the range-drag cursor.\n        scope_Body.style.cursor = getComputedStyle(event.target).cursor; // Mark the target with a dragging state.\n\n        if (scope_Handles.length > 1) {\n          addClass(scope_Target, options.cssClasses.drag);\n        } // Prevent text selection when dragging the handles.\n        // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\n        // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\n        // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.\n        // The 'cursor' flag is false.\n        // See: http://caniuse.com/#search=selectstart\n\n\n        scope_Body.addEventListener(\"selectstart\", preventDefault, false);\n      }\n\n      data.handleNumbers.forEach(function (handleNumber) {\n        fireEvent(\"start\", handleNumber);\n      });\n    } // Move closest handle to tapped location.\n\n\n    function eventTap(event) {\n      // The tap event shouldn't propagate up\n      event.stopPropagation();\n      var proposal = calcPointToPercentage(event.calcPoint);\n      var handleNumber = getClosestHandle(proposal); // Tackle the case that all handles are 'disabled'.\n\n      if (handleNumber === false) {\n        return;\n      } // Flag the slider as it is now in a transitional state.\n      // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\n\n\n      if (!options.events.snap) {\n        addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n      }\n\n      setHandle(handleNumber, proposal, true, true);\n      setZindex();\n      fireEvent(\"slide\", handleNumber, true);\n      fireEvent(\"update\", handleNumber, true);\n\n      if (!options.events.snap) {\n        fireEvent(\"change\", handleNumber, true);\n        fireEvent(\"set\", handleNumber, true);\n      } else {\n        eventStart(event, {\n          handleNumbers: [handleNumber]\n        });\n      }\n    } // Fires a 'hover' event for a hovered mouse/pen position.\n\n\n    function eventHover(event) {\n      var proposal = calcPointToPercentage(event.calcPoint);\n      var to = scope_Spectrum.getStep(proposal);\n      var value = scope_Spectrum.fromStepping(to);\n      Object.keys(scope_Events).forEach(function (targetEvent) {\n        if (\"hover\" === targetEvent.split(\".\")[0]) {\n          scope_Events[targetEvent].forEach(function (callback) {\n            callback.call(scope_Self, value);\n          });\n        }\n      });\n    } // Handles keydown on focused handles\n    // Don't move the document when pressing arrow keys on focused handles\n\n\n    function eventKeydown(event, handleNumber) {\n      if (isSliderDisabled() || isHandleDisabled(handleNumber)) {\n        return false;\n      }\n\n      var horizontalKeys = [\"Left\", \"Right\"];\n      var verticalKeys = [\"Down\", \"Up\"];\n      var largeStepKeys = [\"PageDown\", \"PageUp\"];\n      var edgeKeys = [\"Home\", \"End\"];\n\n      if (options.dir && !options.ort) {\n        // On an right-to-left slider, the left and right keys act inverted\n        horizontalKeys.reverse();\n      } else if (options.ort && !options.dir) {\n        // On a top-to-bottom slider, the up and down keys act inverted\n        verticalKeys.reverse();\n        largeStepKeys.reverse();\n      } // Strip \"Arrow\" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\n\n      var key = event.key.replace(\"Arrow\", \"\");\n      var isLargeDown = key === largeStepKeys[0];\n      var isLargeUp = key === largeStepKeys[1];\n      var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;\n      var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;\n      var isMin = key === edgeKeys[0];\n      var isMax = key === edgeKeys[1];\n\n      if (!isDown && !isUp && !isMin && !isMax) {\n        return true;\n      }\n\n      event.preventDefault();\n      var to;\n\n      if (isUp || isDown) {\n        var direction = isDown ? 0 : 1;\n        var steps = getNextStepsForHandle(handleNumber);\n        var step = steps[direction]; // At the edge of a slider, do nothing\n\n        if (step === null) {\n          return false;\n        } // No step set, use the default of 10% of the sub-range\n\n\n        if (step === false) {\n          step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);\n        }\n\n        if (isLargeUp || isLargeDown) {\n          step *= options.keyboardPageMultiplier;\n        } else {\n          step *= options.keyboardMultiplier;\n        } // Step over zero-length ranges (#948);\n\n\n        step = Math.max(step, 0.0000001); // Decrement for down steps\n\n        step = (isDown ? -1 : 1) * step;\n        to = scope_Values[handleNumber] + step;\n      } else if (isMax) {\n        // End key\n        to = options.spectrum.xVal[options.spectrum.xVal.length - 1];\n      } else {\n        // Home key\n        to = options.spectrum.xVal[0];\n      }\n\n      setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);\n      fireEvent(\"slide\", handleNumber);\n      fireEvent(\"update\", handleNumber);\n      fireEvent(\"change\", handleNumber);\n      fireEvent(\"set\", handleNumber);\n      return false;\n    } // Attach events to several slider parts.\n\n\n    function bindSliderEvents(behaviour) {\n      // Attach the standard drag event to the handles.\n      if (!behaviour.fixed) {\n        scope_Handles.forEach(function (handle, index) {\n          // These events are only bound to the visual handle\n          // element, not the 'real' origin element.\n          attachEvent(actions.start, handle.children[0], eventStart, {\n            handleNumbers: [index]\n          });\n        });\n      } // Attach the tap event to the slider base.\n\n\n      if (behaviour.tap) {\n        attachEvent(actions.start, scope_Base, eventTap, {});\n      } // Fire hover events\n\n\n      if (behaviour.hover) {\n        attachEvent(actions.move, scope_Base, eventHover, {\n          hover: true\n        });\n      } // Make the range draggable.\n\n\n      if (behaviour.drag) {\n        scope_Connects.forEach(function (connect, index) {\n          if (connect === false || index === 0 || index === scope_Connects.length - 1) {\n            return;\n          }\n\n          var handleBefore = scope_Handles[index - 1];\n          var handleAfter = scope_Handles[index];\n          var eventHolders = [connect];\n          var handlesToDrag = [handleBefore, handleAfter];\n          var handleNumbersToDrag = [index - 1, index];\n          addClass(connect, options.cssClasses.draggable); // When the range is fixed, the entire range can\n          // be dragged by the handles. The handle in the first\n          // origin will propagate the start event upward,\n          // but it needs to be bound manually on the other.\n\n          if (behaviour.fixed) {\n            eventHolders.push(handleBefore.children[0]);\n            eventHolders.push(handleAfter.children[0]);\n          }\n\n          if (behaviour.dragAll) {\n            handlesToDrag = scope_Handles;\n            handleNumbersToDrag = scope_HandleNumbers;\n          }\n\n          eventHolders.forEach(function (eventHolder) {\n            attachEvent(actions.start, eventHolder, eventStart, {\n              handles: handlesToDrag,\n              handleNumbers: handleNumbersToDrag,\n              connect: connect\n            });\n          });\n        });\n      }\n    } // Attach an event to this slider, possibly including a namespace\n\n\n    function bindEvent(namespacedEvent, callback) {\n      scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\n      scope_Events[namespacedEvent].push(callback); // If the event bound is 'update,' fire it immediately for all handles.\n\n      if (namespacedEvent.split(\".\")[0] === \"update\") {\n        scope_Handles.forEach(function (a, index) {\n          fireEvent(\"update\", index);\n        });\n      }\n    }\n\n    function isInternalNamespace(namespace) {\n      return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;\n    } // Undo attachment of event\n\n\n    function removeEvent(namespacedEvent) {\n      var event = namespacedEvent && namespacedEvent.split(\".\")[0];\n      var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;\n      Object.keys(scope_Events).forEach(function (bind) {\n        var tEvent = bind.split(\".\")[0];\n        var tNamespace = bind.substring(tEvent.length);\n\n        if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\n          // only delete protected internal event if intentional\n          if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {\n            delete scope_Events[bind];\n          }\n        }\n      });\n    } // External event handling\n\n\n    function fireEvent(eventName, handleNumber, tap) {\n      Object.keys(scope_Events).forEach(function (targetEvent) {\n        var eventType = targetEvent.split(\".\")[0];\n\n        if (eventName === eventType) {\n          scope_Events[targetEvent].forEach(function (callback) {\n            callback.call( // Use the slider public API as the scope ('this')\n            scope_Self, // Return values as array, so arg_1[arg_2] is always valid.\n            scope_Values.map(options.format.to), // Handle index, 0 or 1\n            handleNumber, // Un-formatted slider values\n            scope_Values.slice(), // Event is fired by tap, true or false\n            tap || false, // Left offset of the handle, in relation to the slider\n            scope_Locations.slice(), // add the slider public API to an accessible parameter when this is unavailable\n            scope_Self);\n          });\n        }\n      });\n    } // Split out the handle positioning logic so the Move event can use it, too\n\n\n    function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {\n      var distance; // For sliders with multiple handles, limit movement to the other handle.\n      // Apply the margin option by adding it to the handle positions.\n\n      if (scope_Handles.length > 1 && !options.events.unconstrained) {\n        if (lookBackward && handleNumber > 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);\n          to = Math.max(to, distance);\n        }\n\n        if (lookForward && handleNumber < scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);\n          to = Math.min(to, distance);\n        }\n      } // The limit option has the opposite effect, limiting handles to a\n      // maximum distance from another. Limit must be > 0, as otherwise\n      // handles would be unmovable.\n\n\n      if (scope_Handles.length > 1 && options.limit) {\n        if (lookBackward && handleNumber > 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);\n          to = Math.min(to, distance);\n        }\n\n        if (lookForward && handleNumber < scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);\n          to = Math.max(to, distance);\n        }\n      } // The padding option keeps the handles a certain distance from the\n      // edges of the slider. Padding must be > 0.\n\n\n      if (options.padding) {\n        if (handleNumber === 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);\n          to = Math.max(to, distance);\n        }\n\n        if (handleNumber === scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);\n          to = Math.min(to, distance);\n        }\n      }\n\n      if (!smoothSteps) {\n        to = scope_Spectrum.getStep(to);\n      } // Limit percentage to the 0 - 100 range\n\n\n      to = limit(to); // Return false if handle can't move\n\n      if (to === reference[handleNumber] && !getValue) {\n        return false;\n      }\n\n      return to;\n    } // Uses slider orientation to create CSS rules. a = base value;\n\n\n    function inRuleOrder(v, a) {\n      var o = options.ort;\n      return (o ? a : v) + \", \" + (o ? v : a);\n    } // Moves handle(s) by a percentage\n    // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\n\n\n    function moveHandles(upward, proposal, locations, handleNumbers, connect) {\n      var proposals = locations.slice(); // Store first handle now, so we still have it in case handleNumbers is reversed\n\n      var firstHandle = handleNumbers[0];\n      var smoothSteps = options.events.smoothSteps;\n      var b = [!upward, upward];\n      var f = [upward, !upward]; // Copy handleNumbers so we don't change the dataset\n\n      handleNumbers = handleNumbers.slice(); // Check to see which handle is 'leading'.\n      // If that one can't move the second can't either.\n\n      if (upward) {\n        handleNumbers.reverse();\n      } // Step 1: get the maximum percentage that any of the handles can move\n\n\n      if (handleNumbers.length > 1) {\n        handleNumbers.forEach(function (handleNumber, o) {\n          var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps); // Stop if one of the handles can't move.\n\n          if (to === false) {\n            proposal = 0;\n          } else {\n            proposal = to - proposals[handleNumber];\n            proposals[handleNumber] = to;\n          }\n        });\n      } // If using one handle, check backward AND forward\n      else {\n        b = f = [true];\n      }\n\n      var state = false; // Step 2: Try to set the handles with the found percentage\n\n      handleNumbers.forEach(function (handleNumber, o) {\n        state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;\n      }); // Step 3: If a handle moved, fire events\n\n      if (state) {\n        handleNumbers.forEach(function (handleNumber) {\n          fireEvent(\"update\", handleNumber);\n          fireEvent(\"slide\", handleNumber);\n        }); // If target is a connect, then fire drag event\n\n        if (connect != undefined) {\n          fireEvent(\"drag\", firstHandle);\n        }\n      }\n    } // Takes a base value and an offset. This offset is used for the connect bar size.\n    // In the initial design for this feature, the origin element was 1% wide.\n    // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\n    // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\n\n\n    function transformDirection(a, b) {\n      return options.dir ? 100 - a - b : a;\n    } // Updates scope_Locations and scope_Values, updates visual state\n\n\n    function updateHandlePosition(handleNumber, to) {\n      // Update locations.\n      scope_Locations[handleNumber] = to; // Convert the value to the slider stepping/range.\n\n      scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\n      var translation = transformDirection(to, 0) - scope_DirOffset;\n      var translateRule = \"translate(\" + inRuleOrder(translation + \"%\", \"0\") + \")\";\n      scope_Handles[handleNumber].style[options.transformRule] = translateRule;\n      updateConnect(handleNumber);\n      updateConnect(handleNumber + 1);\n    } // Handles before the slider middle are stacked later = higher,\n    // Handles after the middle later is lower\n    // [[7] [8] .......... | .......... [5] [4]\n\n\n    function setZindex() {\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\n        var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\n        scope_Handles[handleNumber].style.zIndex = String(zIndex);\n      });\n    } // Test suggested values and apply margin, step.\n    // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)\n\n\n    function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {\n      if (!exactInput) {\n        to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);\n      }\n\n      if (to === false) {\n        return false;\n      }\n\n      updateHandlePosition(handleNumber, to);\n      return true;\n    } // Updates style attribute for connect nodes\n\n\n    function updateConnect(index) {\n      // Skip connects set to false\n      if (!scope_Connects[index]) {\n        return;\n      }\n\n      var l = 0;\n      var h = 100;\n\n      if (index !== 0) {\n        l = scope_Locations[index - 1];\n      }\n\n      if (index !== scope_Connects.length - 1) {\n        h = scope_Locations[index];\n      } // We use two rules:\n      // 'translate' to change the left/top offset;\n      // 'scale' to change the width of the element;\n      // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\n\n\n      var connectWidth = h - l;\n      var translateRule = \"translate(\" + inRuleOrder(transformDirection(l, connectWidth) + \"%\", \"0\") + \")\";\n      var scaleRule = \"scale(\" + inRuleOrder(connectWidth / 100, \"1\") + \")\";\n      scope_Connects[index].style[options.transformRule] = translateRule + \" \" + scaleRule;\n    } // Parses value passed to .set method. Returns current value if not parse-able.\n\n\n    function resolveToValue(to, handleNumber) {\n      // Setting with null indicates an 'ignore'.\n      // Inputting 'false' is invalid.\n      if (to === null || to === false || to === undefined) {\n        return scope_Locations[handleNumber];\n      } // If a formatted number was passed, attempt to decode it.\n\n\n      if (typeof to === \"number\") {\n        to = String(to);\n      }\n\n      to = options.format.from(to);\n\n      if (to !== false) {\n        to = scope_Spectrum.toStepping(to);\n      } // If parsing the number failed, use the current value.\n\n\n      if (to === false || isNaN(to)) {\n        return scope_Locations[handleNumber];\n      }\n\n      return to;\n    } // Set the slider value.\n\n\n    function valueSet(input, fireSetEvent, exactInput) {\n      var values = asArray(input);\n      var isInit = scope_Locations[0] === undefined; // Event fires by default\n\n      fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent; // Animation is optional.\n      // Make sure the initial values were set before using animated placement.\n\n      if (options.animate && !isInit) {\n        addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n      } // First pass, without lookAhead but with lookBackward. Values are set from left to right.\n\n\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);\n      });\n      var i = scope_HandleNumbers.length === 1 ? 0 : 1; // Spread handles evenly across the slider if the range has no size (min=max)\n\n      if (isInit && scope_Spectrum.hasNoSize()) {\n        exactInput = true;\n        scope_Locations[0] = 0;\n\n        if (scope_HandleNumbers.length > 1) {\n          var space_1 = 100 / (scope_HandleNumbers.length - 1);\n          scope_HandleNumbers.forEach(function (handleNumber) {\n            scope_Locations[handleNumber] = handleNumber * space_1;\n          });\n        }\n      } // Secondary passes. Now that all base values are set, apply constraints.\n      // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)\n\n\n      for (; i < scope_HandleNumbers.length; ++i) {\n        scope_HandleNumbers.forEach(function (handleNumber) {\n          setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);\n        });\n      }\n\n      setZindex();\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        fireEvent(\"update\", handleNumber); // Fire the event only for handles that received a new value, as per #579\n\n        if (values[handleNumber] !== null && fireSetEvent) {\n          fireEvent(\"set\", handleNumber);\n        }\n      });\n    } // Reset slider to initial values\n\n\n    function valueReset(fireSetEvent) {\n      valueSet(options.start, fireSetEvent);\n    } // Set value for a single handle\n\n\n    function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {\n      // Ensure numeric input\n      handleNumber = Number(handleNumber);\n\n      if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\n        throw new Error(\"noUiSlider: invalid handle number, got: \" + handleNumber);\n      } // Look both backward and forward, since we don't want this handle to \"push\" other handles (#960);\n      // The exactInput argument can be used to ignore slider stepping (#436)\n\n\n      setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);\n      fireEvent(\"update\", handleNumber);\n\n      if (fireSetEvent) {\n        fireEvent(\"set\", handleNumber);\n      }\n    } // Get the slider value.\n\n\n    function valueGet(unencoded) {\n      if (unencoded === void 0) {\n        unencoded = false;\n      }\n\n      if (unencoded) {\n        // return a copy of the raw values\n        return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);\n      }\n\n      var values = scope_Values.map(options.format.to); // If only one handle is used, return a single value.\n\n      if (values.length === 1) {\n        return values[0];\n      }\n\n      return values;\n    } // Removes classes from the root and empties it.\n\n\n    function destroy() {\n      // remove protected internal listeners\n      removeEvent(INTERNAL_EVENT_NS.aria);\n      removeEvent(INTERNAL_EVENT_NS.tooltips);\n      Object.keys(options.cssClasses).forEach(function (key) {\n        removeClass(scope_Target, options.cssClasses[key]);\n      });\n\n      while (scope_Target.firstChild) {\n        scope_Target.removeChild(scope_Target.firstChild);\n      }\n\n      delete scope_Target.noUiSlider;\n    }\n\n    function getNextStepsForHandle(handleNumber) {\n      var location = scope_Locations[handleNumber];\n      var nearbySteps = scope_Spectrum.getNearbySteps(location);\n      var value = scope_Values[handleNumber];\n      var increment = nearbySteps.thisStep.step;\n      var decrement = null; // If snapped, directly use defined step value\n\n      if (options.snap) {\n        return [value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null];\n      } // If the next value in this step moves into the next step,\n      // the increment is the start of the next step - the current value\n\n\n      if (increment !== false) {\n        if (value + increment > nearbySteps.stepAfter.startValue) {\n          increment = nearbySteps.stepAfter.startValue - value;\n        }\n      } // If the value is beyond the starting point\n\n\n      if (value > nearbySteps.thisStep.startValue) {\n        decrement = nearbySteps.thisStep.step;\n      } else if (nearbySteps.stepBefore.step === false) {\n        decrement = false;\n      } // If a handle is at the start of a step, it always steps back into the previous step first\n      else {\n        decrement = value - nearbySteps.stepBefore.highestStep;\n      } // Now, if at the slider edges, there is no in/decrement\n\n\n      if (location === 100) {\n        increment = null;\n      } else if (location === 0) {\n        decrement = null;\n      } // As per #391, the comparison for the decrement step can have some rounding issues.\n\n\n      var stepDecimals = scope_Spectrum.countStepDecimals(); // Round per #391\n\n      if (increment !== null && increment !== false) {\n        increment = Number(increment.toFixed(stepDecimals));\n      }\n\n      if (decrement !== null && decrement !== false) {\n        decrement = Number(decrement.toFixed(stepDecimals));\n      }\n\n      return [decrement, increment];\n    } // Get the current step size for the slider.\n\n\n    function getNextSteps() {\n      return scope_HandleNumbers.map(getNextStepsForHandle);\n    } // Updatable: margin, limit, padding, step, range, animate, snap\n\n\n    function updateOptions(optionsToUpdate, fireSetEvent) {\n      // Spectrum is created using the range, snap, direction and step options.\n      // 'snap' and 'step' can be updated.\n      // If 'snap' and 'step' are not passed, they should remain unchanged.\n      var v = valueGet();\n      var updateAble = [\"margin\", \"limit\", \"padding\", \"range\", \"animate\", \"snap\", \"step\", \"format\", \"pips\", \"tooltips\"]; // Only change options that we're actually passed to update.\n\n      updateAble.forEach(function (name) {\n        // Check for undefined. null removes the value.\n        if (optionsToUpdate[name] !== undefined) {\n          originalOptions[name] = optionsToUpdate[name];\n        }\n      });\n      var newOptions = testOptions(originalOptions); // Load new options into the slider state\n\n      updateAble.forEach(function (name) {\n        if (optionsToUpdate[name] !== undefined) {\n          options[name] = newOptions[name];\n        }\n      });\n      scope_Spectrum = newOptions.spectrum; // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\n\n      options.margin = newOptions.margin;\n      options.limit = newOptions.limit;\n      options.padding = newOptions.padding; // Update pips, removes existing.\n\n      if (options.pips) {\n        pips(options.pips);\n      } else {\n        removePips();\n      } // Update tooltips, removes existing.\n\n\n      if (options.tooltips) {\n        tooltips();\n      } else {\n        removeTooltips();\n      } // Invalidate the current positioning so valueSet forces an update.\n\n\n      scope_Locations = [];\n      valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);\n    } // Initialization steps\n\n\n    function setupSlider() {\n      // Create the base element, initialize HTML and set classes.\n      // Add handles and connect elements.\n      scope_Base = addSlider(scope_Target);\n      addElements(options.connect, scope_Base); // Attach user events.\n\n      bindSliderEvents(options.events); // Use the public value method to set the start values.\n\n      valueSet(options.start);\n\n      if (options.pips) {\n        pips(options.pips);\n      }\n\n      if (options.tooltips) {\n        tooltips();\n      }\n\n      aria();\n    }\n\n    setupSlider();\n    var scope_Self = {\n      destroy: destroy,\n      steps: getNextSteps,\n      on: bindEvent,\n      off: removeEvent,\n      get: valueGet,\n      set: valueSet,\n      setHandle: valueSetHandle,\n      reset: valueReset,\n      // Exposed for unit testing, don't use this in your application.\n      __moveHandles: function __moveHandles(upward, proposal, handleNumbers) {\n        moveHandles(upward, proposal, scope_Locations, handleNumbers);\n      },\n      options: originalOptions,\n      updateOptions: updateOptions,\n      target: scope_Target,\n      removePips: removePips,\n      removeTooltips: removeTooltips,\n      getPositions: function getPositions() {\n        return scope_Locations.slice();\n      },\n      getTooltips: function getTooltips() {\n        return scope_Tooltips;\n      },\n      getOrigins: function getOrigins() {\n        return scope_Handles;\n      },\n      pips: pips // Issue #594\n\n    };\n    return scope_Self;\n  } // Run the standard initializer\n\n\n  function initialize(target, originalOptions) {\n    if (!target || !target.nodeName) {\n      throw new Error(\"noUiSlider: create requires a single element, got: \" + target);\n    } // Throw an error if the slider was already initialized.\n\n\n    if (target.noUiSlider) {\n      throw new Error(\"noUiSlider: Slider was already initialized.\");\n    } // Test the options and create the slider environment;\n\n\n    var options = testOptions(originalOptions);\n    var api = scope(target, options, originalOptions);\n    target.noUiSlider = api;\n    return api;\n  }\n\n  var nouislider = {\n    // Exposed for unit testing, don't use this in your application.\n    __spectrum: Spectrum,\n    // A reference to the default classes, allows global changes.\n    // Use the cssClasses option for changes to one slider.\n    cssClasses: cssClasses,\n    create: initialize\n  };\n  exports.create = initialize;\n  exports.cssClasses = cssClasses;\n  exports[\"default\"] = nouislider;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0L25vdWlzbGlkZXIuanM/ZjUyOCJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsIlBpcHNNb2RlIiwiUGlwc1R5cGUiLCJpc1ZhbGlkRm9ybWF0dGVyIiwiZW50cnkiLCJpc1ZhbGlkUGFydGlhbEZvcm1hdHRlciIsImZyb20iLCJ0byIsInJlbW92ZUVsZW1lbnQiLCJlbCIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsImlzU2V0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJwcmV2ZW50RGVmYXVsdCIsImUiLCJ1bmlxdWUiLCJhcnJheSIsImZpbHRlciIsImEiLCJjbG9zZXN0IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0IiwiZWxlbSIsIm9yaWVudGF0aW9uIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRFbGVtZW50IiwicGFnZU9mZnNldCIsImdldFBhZ2VPZmZzZXQiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwieCIsInRvcCIsInkiLCJjbGllbnRUb3AiLCJsZWZ0IiwiY2xpZW50TGVmdCIsImlzTnVtZXJpYyIsImlzTmFOIiwiaXNGaW5pdGUiLCJhZGRDbGFzc0ZvciIsImVsZW1lbnQiLCJjbGFzc05hbWUiLCJkdXJhdGlvbiIsImFkZENsYXNzIiwic2V0VGltZW91dCIsInJlbW92ZUNsYXNzIiwibGltaXQiLCJtYXgiLCJtaW4iLCJhc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiY291bnREZWNpbWFscyIsIm51bVN0ciIsIlN0cmluZyIsInBpZWNlcyIsInNwbGl0IiwibGVuZ3RoIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwicmVwbGFjZSIsIlJlZ0V4cCIsImpvaW4iLCJoYXNDbGFzcyIsImNvbnRhaW5zIiwic3VwcG9ydFBhZ2VPZmZzZXQiLCJ3aW5kb3ciLCJwYWdlWE9mZnNldCIsImlzQ1NTMUNvbXBhdCIsImNvbXBhdE1vZGUiLCJzY3JvbGxMZWZ0IiwiYm9keSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiZ2V0QWN0aW9ucyIsInBvaW50ZXJFbmFibGVkIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwibXNQb2ludGVyRW5hYmxlZCIsImdldFN1cHBvcnRzUGFzc2l2ZSIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSIsIkNTUyIsInN1cHBvcnRzIiwic3ViUmFuZ2VSYXRpbyIsInBhIiwicGIiLCJmcm9tUGVyY2VudGFnZSIsInJhbmdlIiwic3RhcnRSYW5nZSIsInRvUGVyY2VudGFnZSIsImFicyIsImlzUGVyY2VudGFnZSIsImdldEoiLCJhcnIiLCJqIiwidG9TdGVwcGluZyIsInhWYWwiLCJ4UGN0Iiwic2xpY2UiLCJ2YSIsInZiIiwiZnJvbVN0ZXBwaW5nIiwiZ2V0U3RlcCIsInhTdGVwcyIsInNuYXAiLCJiIiwiU3BlY3RydW0iLCJzaW5nbGVTdGVwIiwieE51bVN0ZXBzIiwieEhpZ2hlc3RDb21wbGV0ZVN0ZXAiLCJpbmRleCIsIm9yZGVyZWQiLCJrZXlzIiwiZm9yRWFjaCIsInB1c2giLCJzb3J0IiwiaGFuZGxlRW50cnlQb2ludCIsImhhbmRsZVN0ZXBQb2ludCIsInByb3RvdHlwZSIsImdldERpc3RhbmNlIiwiZGlzdGFuY2VzIiwiZ2V0QWJzb2x1dGVEaXN0YW5jZSIsImRpcmVjdGlvbiIsInhQY3RfaW5kZXgiLCJzdGFydF9mYWN0b3IiLCJyZXN0X2ZhY3RvciIsInJlc3RfcmVsX2Rpc3RhbmNlIiwicmFuZ2VfcGN0IiwicmVsX3JhbmdlX2Rpc3RhbmNlIiwiYWJzX2Rpc3RhbmNlX2NvdW50ZXIiLCJyYW5nZV9jb3VudGVyIiwiZ2V0RGVmYXVsdFN0ZXAiLCJpc0Rvd24iLCJzaXplIiwiZ2V0TmVhcmJ5U3RlcHMiLCJzdGVwQmVmb3JlIiwic3RhcnRWYWx1ZSIsInN0ZXAiLCJoaWdoZXN0U3RlcCIsInRoaXNTdGVwIiwic3RlcEFmdGVyIiwiY291bnRTdGVwRGVjaW1hbHMiLCJzdGVwRGVjaW1hbHMiLCJtYXAiLCJhcHBseSIsImhhc05vU2l6ZSIsImNvbnZlcnQiLCJwZXJjZW50YWdlIiwicGFyc2VGbG9hdCIsIkVycm9yIiwidmFsdWUxIiwiTnVtYmVyIiwiaSIsIm4iLCJ0b3RhbFN0ZXBzIiwiY2VpbCIsInRvRml4ZWQiLCJkZWZhdWx0Rm9ybWF0dGVyIiwiY3NzQ2xhc3NlcyIsInRhcmdldCIsImJhc2UiLCJvcmlnaW4iLCJoYW5kbGUiLCJoYW5kbGVMb3dlciIsImhhbmRsZVVwcGVyIiwidG91Y2hBcmVhIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYmFja2dyb3VuZCIsImNvbm5lY3QiLCJjb25uZWN0cyIsImx0ciIsInJ0bCIsInRleHREaXJlY3Rpb25MdHIiLCJ0ZXh0RGlyZWN0aW9uUnRsIiwiZHJhZ2dhYmxlIiwiZHJhZyIsInRhcCIsImFjdGl2ZSIsInRvb2x0aXAiLCJwaXBzIiwicGlwc0hvcml6b250YWwiLCJwaXBzVmVydGljYWwiLCJtYXJrZXIiLCJtYXJrZXJIb3Jpem9udGFsIiwibWFya2VyVmVydGljYWwiLCJtYXJrZXJOb3JtYWwiLCJtYXJrZXJMYXJnZSIsIm1hcmtlclN1YiIsInZhbHVlSG9yaXpvbnRhbCIsInZhbHVlVmVydGljYWwiLCJ2YWx1ZU5vcm1hbCIsInZhbHVlTGFyZ2UiLCJ2YWx1ZVN1YiIsIklOVEVSTkFMX0VWRU5UX05TIiwidG9vbHRpcHMiLCJhcmlhIiwidGVzdFN0ZXAiLCJwYXJzZWQiLCJ0ZXN0S2V5Ym9hcmRQYWdlTXVsdGlwbGllciIsImtleWJvYXJkUGFnZU11bHRpcGxpZXIiLCJ0ZXN0S2V5Ym9hcmRNdWx0aXBsaWVyIiwia2V5Ym9hcmRNdWx0aXBsaWVyIiwidGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAiLCJrZXlib2FyZERlZmF1bHRTdGVwIiwidGVzdFJhbmdlIiwic3BlY3RydW0iLCJ0ZXN0U3RhcnQiLCJoYW5kbGVzIiwidGVzdFNuYXAiLCJ0ZXN0QW5pbWF0ZSIsImFuaW1hdGUiLCJ0ZXN0QW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25EdXJhdGlvbiIsInRlc3RDb25uZWN0IiwidGVzdE9yaWVudGF0aW9uIiwib3J0IiwidGVzdE1hcmdpbiIsIm1hcmdpbiIsInRlc3RMaW1pdCIsInRlc3RQYWRkaW5nIiwicGFkZGluZyIsInRvdGFsUGFkZGluZyIsImZpcnN0VmFsdWUiLCJsYXN0VmFsdWUiLCJ0ZXN0RGlyZWN0aW9uIiwiZGlyIiwidGVzdEJlaGF2aW91ciIsImluZGV4T2YiLCJmaXhlZCIsImhvdmVyIiwidW5jb25zdHJhaW5lZCIsImRyYWdBbGwiLCJzbW9vdGhTdGVwcyIsImV2ZW50cyIsInRlc3RUb29sdGlwcyIsImZvcm1hdHRlciIsInRlc3RIYW5kbGVBdHRyaWJ1dGVzIiwiaGFuZGxlQXR0cmlidXRlcyIsInRlc3RBcmlhRm9ybWF0IiwiYXJpYUZvcm1hdCIsInRlc3RGb3JtYXQiLCJmb3JtYXQiLCJ0ZXN0S2V5Ym9hcmRTdXBwb3J0Iiwia2V5Ym9hcmRTdXBwb3J0IiwidGVzdERvY3VtZW50RWxlbWVudCIsInRlc3RDc3NQcmVmaXgiLCJjc3NQcmVmaXgiLCJ0ZXN0Q3NzQ2xhc3NlcyIsImtleSIsInRlc3RPcHRpb25zIiwib3B0aW9ucyIsInRlc3RzIiwiciIsInQiLCJiZWhhdmlvdXIiLCJkZWZhdWx0cyIsIm5hbWUiLCJkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibXNQcmVmaXgiLCJzdHlsZSIsIm1zVHJhbnNmb3JtIiwibm9QcmVmaXgiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1SdWxlIiwic3R5bGVzIiwic2NvcGUiLCJvcmlnaW5hbE9wdGlvbnMiLCJhY3Rpb25zIiwic3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUiLCJzY29wZV9UYXJnZXQiLCJzY29wZV9CYXNlIiwic2NvcGVfSGFuZGxlcyIsInNjb3BlX0Nvbm5lY3RzIiwic2NvcGVfUGlwcyIsInNjb3BlX1Rvb2x0aXBzIiwic2NvcGVfU3BlY3RydW0iLCJzY29wZV9WYWx1ZXMiLCJzY29wZV9Mb2NhdGlvbnMiLCJzY29wZV9IYW5kbGVOdW1iZXJzIiwic2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50Iiwic2NvcGVfRXZlbnRzIiwic2NvcGVfRG9jdW1lbnQiLCJzY29wZV9Eb2N1bWVudEVsZW1lbnQiLCJzY29wZV9Cb2R5Iiwic2NvcGVfRGlyT2Zmc2V0IiwiYWRkTm9kZVRvIiwiYWRkVGFyZ2V0IiwiZGl2IiwiYXBwZW5kQ2hpbGQiLCJhZGRPcmlnaW4iLCJoYW5kbGVOdW1iZXIiLCJzZXRBdHRyaWJ1dGUiLCJldmVudCIsImV2ZW50S2V5ZG93biIsImF0dHJpYnV0ZXNfMSIsImF0dHJpYnV0ZSIsImFkZENvbm5lY3QiLCJhZGRFbGVtZW50cyIsImNvbm5lY3RPcHRpb25zIiwiY29ubmVjdEJhc2UiLCJhZGRTbGlkZXIiLCJ0ZXh0RGlyZWN0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFkZFRvb2x0aXAiLCJmaXJzdENoaWxkIiwiaXNTbGlkZXJEaXNhYmxlZCIsImhhc0F0dHJpYnV0ZSIsImlzSGFuZGxlRGlzYWJsZWQiLCJoYW5kbGVPcmlnaW4iLCJyZW1vdmVUb29sdGlwcyIsInJlbW92ZUV2ZW50IiwiYmluZEV2ZW50IiwidmFsdWVzIiwidW5lbmNvZGVkIiwiZm9ybWF0dGVkVmFsdWUiLCJpbm5lckhUTUwiLCJwb3NpdGlvbnMiLCJjaGVja0hhbmRsZVBvc2l0aW9uIiwibm93IiwidGV4dCIsImNoaWxkcmVuIiwiZ2V0R3JvdXAiLCJtb2RlIiwiUmFuZ2UiLCJTdGVwcyIsIkNvdW50IiwiaW50ZXJ2YWwiLCJzcHJlYWQiLCJtYXBUb1JhbmdlIiwic3RlcHBlZCIsIlBvc2l0aW9ucyIsIlZhbHVlcyIsImdlbmVyYXRlU3ByZWFkIiwic2FmZUluY3JlbWVudCIsImluY3JlbWVudCIsImdyb3VwIiwiaW5kZXhlcyIsImZpcnN0SW5SYW5nZSIsImxhc3RJblJhbmdlIiwiaWdub3JlRmlyc3QiLCJpZ25vcmVMYXN0IiwicHJldlBjdCIsInVuc2hpZnQiLCJjdXJyZW50IiwicSIsImxvdyIsImhpZ2giLCJuZXdQY3QiLCJwY3REaWZmZXJlbmNlIiwicGN0UG9zIiwidHlwZSIsInN0ZXBzIiwicmVhbFN0ZXBzIiwic3RlcFNpemUiLCJpc1N0ZXBzIiwiZGVuc2l0eSIsIkxhcmdlVmFsdWUiLCJTbWFsbFZhbHVlIiwiTm9WYWx1ZSIsImFkZE1hcmtpbmciLCJmaWx0ZXJGdW5jIiwiX2EiLCJfYiIsInZhbHVlU2l6ZUNsYXNzZXMiLCJOb25lIiwibWFya2VyU2l6ZUNsYXNzZXMiLCJ2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyIsIm1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcyIsImdldENsYXNzZXMiLCJzb3VyY2UiLCJvcmllbnRhdGlvbkNsYXNzZXMiLCJzaXplQ2xhc3NlcyIsImFkZFNwcmVhZCIsIm5vZGUiLCJyZW1vdmVQaXBzIiwiYmFzZVNpemUiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsImF0dGFjaEV2ZW50IiwiY2FsbGJhY2siLCJkYXRhIiwibWV0aG9kIiwiZml4RXZlbnQiLCJkb05vdFJlamVjdCIsImJ1dHRvbnMiLCJjYWxjUG9pbnQiLCJwb2ludHMiLCJtZXRob2RzIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsImV2ZW50VGFyZ2V0IiwidG91Y2giLCJtb3VzZSIsInBvaW50ZXIiLCJ0b3VjaGVzIiwiaXNUb3VjaE9uVGFyZ2V0IiwiY2hlY2tUb3VjaCIsImNvbXBvc2VkIiwiY29tcG9zZWRQYXRoIiwic2hpZnQiLCJ0YXJnZXRUb3VjaGVzIiwiY2FsbCIsInBhZ2VYIiwicGFnZVkiLCJ0YXJnZXRUb3VjaCIsImZpbmQiLCJjaGFuZ2VkVG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwiY3Vyc29yIiwiY2FsY1BvaW50VG9QZXJjZW50YWdlIiwibG9jYXRpb24iLCJwcm9wb3NhbCIsImdldENsb3Nlc3RIYW5kbGUiLCJjbGlja2VkUG9zaXRpb24iLCJzbWFsbGVzdERpZmZlcmVuY2UiLCJoYW5kbGVQb3NpdGlvbiIsImRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSIsImNsaWNrQXRFZGdlIiwiaXNDbG9zZXIiLCJpc0Nsb3NlckFmdGVyIiwiZG9jdW1lbnRMZWF2ZSIsIm5vZGVOYW1lIiwicmVsYXRlZFRhcmdldCIsImV2ZW50RW5kIiwiZXZlbnRNb3ZlIiwiYXBwVmVyc2lvbiIsImJ1dHRvbnNQcm9wZXJ0eSIsIm1vdmVtZW50Iiwic3RhcnRDYWxjUG9pbnQiLCJtb3ZlSGFuZGxlcyIsImxvY2F0aW9ucyIsImhhbmRsZU51bWJlcnMiLCJsaXN0ZW5lcnMiLCJjIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFppbmRleCIsInNldEhhbmRsZSIsImZpcmVFdmVudCIsImV2ZW50U3RhcnQiLCJzb21lIiwic3RvcFByb3BhZ2F0aW9uIiwibW92ZUV2ZW50IiwiZW5kRXZlbnQiLCJvdXRFdmVudCIsImNvbmNhdCIsImV2ZW50VGFwIiwiZXZlbnRIb3ZlciIsInRhcmdldEV2ZW50Iiwic2NvcGVfU2VsZiIsImhvcml6b250YWxLZXlzIiwidmVydGljYWxLZXlzIiwibGFyZ2VTdGVwS2V5cyIsImVkZ2VLZXlzIiwicmV2ZXJzZSIsImlzTGFyZ2VEb3duIiwiaXNMYXJnZVVwIiwiaXNVcCIsImlzTWluIiwiaXNNYXgiLCJnZXROZXh0U3RlcHNGb3JIYW5kbGUiLCJiaW5kU2xpZGVyRXZlbnRzIiwiaGFuZGxlQmVmb3JlIiwiaGFuZGxlQWZ0ZXIiLCJldmVudEhvbGRlcnMiLCJoYW5kbGVzVG9EcmFnIiwiaGFuZGxlTnVtYmVyc1RvRHJhZyIsImV2ZW50SG9sZGVyIiwibmFtZXNwYWNlZEV2ZW50IiwiaXNJbnRlcm5hbE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInN1YnN0cmluZyIsImJpbmQiLCJ0RXZlbnQiLCJ0TmFtZXNwYWNlIiwiZXZlbnRUeXBlIiwicmVmZXJlbmNlIiwibG9va0JhY2t3YXJkIiwibG9va0ZvcndhcmQiLCJnZXRWYWx1ZSIsImRpc3RhbmNlIiwiaW5SdWxlT3JkZXIiLCJ2IiwibyIsInVwd2FyZCIsInByb3Bvc2FscyIsImZpcnN0SGFuZGxlIiwiZiIsInN0YXRlIiwidHJhbnNmb3JtRGlyZWN0aW9uIiwidXBkYXRlSGFuZGxlUG9zaXRpb24iLCJ0cmFuc2xhdGlvbiIsInRyYW5zbGF0ZVJ1bGUiLCJ1cGRhdGVDb25uZWN0IiwiekluZGV4IiwiZXhhY3RJbnB1dCIsImwiLCJoIiwiY29ubmVjdFdpZHRoIiwic2NhbGVSdWxlIiwicmVzb2x2ZVRvVmFsdWUiLCJ2YWx1ZVNldCIsImlucHV0IiwiZmlyZVNldEV2ZW50IiwiaXNJbml0Iiwic3BhY2VfMSIsInZhbHVlUmVzZXQiLCJ2YWx1ZVNldEhhbmRsZSIsInZhbHVlR2V0IiwiZGVzdHJveSIsIm5vVWlTbGlkZXIiLCJuZWFyYnlTdGVwcyIsImRlY3JlbWVudCIsImdldE5leHRTdGVwcyIsInVwZGF0ZU9wdGlvbnMiLCJvcHRpb25zVG9VcGRhdGUiLCJ1cGRhdGVBYmxlIiwibmV3T3B0aW9ucyIsInNldHVwU2xpZGVyIiwib24iLCJvZmYiLCJzZXQiLCJyZXNldCIsIl9fbW92ZUhhbmRsZXMiLCJnZXRQb3NpdGlvbnMiLCJnZXRUb29sdGlwcyIsImdldE9yaWdpbnMiLCJpbml0aWFsaXplIiwiYXBpIiwibm91aXNsaWRlciIsIl9fc3BlY3RydW0iLCJjcmVhdGUiXSwibWFwcGluZ3MiOiI7O0FBQUEsQ0FBQyxVQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtFQUN4Qiw4QkFBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQixPQUFPQyxNQUFQLEtBQWtCLFdBQWpELEdBQStERixPQUFPLENBQUNDLE9BQUQsQ0FBdEUsR0FDQSxRQUE2Q0UsaUNBQU8sQ0FBQyxPQUFELENBQUQsb0NBQWNILE9BQWQ7QUFBQTtBQUFBO0FBQUEsb0dBQW5ELElBQ0NELFNBREQsQ0FEQTtBQUdILENBSkQsRUFJRyxJQUpILEVBSVUsVUFBVUUs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QUFrQmtCLGVBQWxCLENBQWY7SUFDQTlHLE1BQU0sQ0FBQ21XLFVBQVAsR0FBb0JrQixHQUFwQjtJQUNBLE9BQU9BLEdBQVA7RUFDSDs7RUFDRCxJQUFJQyxVQUFVLEdBQUc7SUFDYjtJQUNBQyxVQUFVLEVBQUU1YSxRQUZDO0lBR2I7SUFDQTtJQUNBb0QsVUFBVSxFQUFFQSxVQUxDO0lBTWJ5WCxNQUFNLEVBQUVKO0VBTkssQ0FBakI7RUFTQXJpQixPQUFPLENBQUN5aUIsTUFBUixHQUFpQkosVUFBakI7RUFDQXJpQixPQUFPLENBQUNnTCxVQUFSLEdBQXFCQSxVQUFyQjtFQUNBaEwsT0FBTyxDQUFDLFNBQUQsQ0FBUCxHQUFxQnVpQixVQUFyQjtFQUVBemMsTUFBTSxDQUFDQyxjQUFQLENBQXNCL0YsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7SUFBRWUsS0FBSyxFQUFFO0VBQVQsQ0FBN0M7QUFFSCxDQTdzRUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0L25vdWlzbGlkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLm5vVWlTbGlkZXIgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGV4cG9ydHMuUGlwc01vZGUgPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChQaXBzTW9kZSkge1xuICAgICAgICBQaXBzTW9kZVtcIlJhbmdlXCJdID0gXCJyYW5nZVwiO1xuICAgICAgICBQaXBzTW9kZVtcIlN0ZXBzXCJdID0gXCJzdGVwc1wiO1xuICAgICAgICBQaXBzTW9kZVtcIlBvc2l0aW9uc1wiXSA9IFwicG9zaXRpb25zXCI7XG4gICAgICAgIFBpcHNNb2RlW1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgICAgIFBpcHNNb2RlW1wiVmFsdWVzXCJdID0gXCJ2YWx1ZXNcIjtcbiAgICB9KShleHBvcnRzLlBpcHNNb2RlIHx8IChleHBvcnRzLlBpcHNNb2RlID0ge30pKTtcbiAgICBleHBvcnRzLlBpcHNUeXBlID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoUGlwc1R5cGUpIHtcbiAgICAgICAgUGlwc1R5cGVbUGlwc1R5cGVbXCJOb25lXCJdID0gLTFdID0gXCJOb25lXCI7XG4gICAgICAgIFBpcHNUeXBlW1BpcHNUeXBlW1wiTm9WYWx1ZVwiXSA9IDBdID0gXCJOb1ZhbHVlXCI7XG4gICAgICAgIFBpcHNUeXBlW1BpcHNUeXBlW1wiTGFyZ2VWYWx1ZVwiXSA9IDFdID0gXCJMYXJnZVZhbHVlXCI7XG4gICAgICAgIFBpcHNUeXBlW1BpcHNUeXBlW1wiU21hbGxWYWx1ZVwiXSA9IDJdID0gXCJTbWFsbFZhbHVlXCI7XG4gICAgfSkoZXhwb3J0cy5QaXBzVHlwZSB8fCAoZXhwb3J0cy5QaXBzVHlwZSA9IHt9KSk7XG4gICAgLy9yZWdpb24gSGVscGVyIE1ldGhvZHNcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkUGFydGlhbEZvcm1hdHRlcihlbnRyeSkgJiYgdHlwZW9mIGVudHJ5LmZyb20gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZFBhcnRpYWxGb3JtYXR0ZXIoZW50cnkpIHtcbiAgICAgICAgLy8gcGFydGlhbCBmb3JtYXR0ZXJzIG9ubHkgbmVlZCBhIHRvIGZ1bmN0aW9uIGFuZCBub3QgYSBmcm9tIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGVudHJ5LnRvID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBCaW5kYWJsZSB2ZXJzaW9uXG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LlxuICAgIGZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXNbYV0gPyAodGhpc1thXSA9IHRydWUpIDogZmFsc2U7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLy8gUm91bmQgYSB2YWx1ZSB0byB0aGUgY2xvc2VzdCAndG8nLlxuICAgIGZ1bmN0aW9uIGNsb3Nlc3QodmFsdWUsIHRvKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0sIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxuICAgICAgICAvLyBJIGhhdmVuJ3QgZm91bmQgYSBmZWF0dXJlIGRldGVjdGlvbiB0aGF0IHByb3ZlcyB0aGlzLiBXb3JzdCBjYXNlXG4gICAgICAgIC8vIHNjZW5hcmlvIG9uIG1pcy1tYXRjaDogdGhlICd0YXAnIGZlYXR1cmUgb24gaG9yaXpvbnRhbCBzbGlkZXJzIGJyZWFrcy5cbiAgICAgICAgaWYgKC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcGFnZU9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZW50YXRpb24gPyByZWN0LnRvcCArIHBhZ2VPZmZzZXQueSAtIGRvY0VsZW0uY2xpZW50VG9wIDogcmVjdC5sZWZ0ICsgcGFnZU9mZnNldC54IC0gZG9jRWxlbS5jbGllbnRMZWZ0O1xuICAgIH1cbiAgICAvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cbiAgICBmdW5jdGlvbiBpc051bWVyaWMoYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGEpICYmIGlzRmluaXRlKGEpO1xuICAgIH1cbiAgICAvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cbiAgICBmdW5jdGlvbiBhZGRDbGFzc0ZvcihlbGVtZW50LCBjbGFzc05hbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcbiAgICBmdW5jdGlvbiBsaW1pdChhKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihhLCAxMDApLCAwKTtcbiAgICB9XG4gICAgLy8gV3JhcHMgYSB2YXJpYWJsZSBhcyBhbiBhcnJheSwgaWYgaXQgaXNuJ3Qgb25lIHlldC5cbiAgICAvLyBOb3RlIHRoYXQgYW4gaW5wdXQgYXJyYXkgaXMgcmV0dXJuZWQgYnkgcmVmZXJlbmNlIVxuICAgIGZ1bmN0aW9uIGFzQXJyYXkoYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgfVxuICAgIC8vIENvdW50cyBkZWNpbWFsc1xuICAgIGZ1bmN0aW9uIGNvdW50RGVjaW1hbHMobnVtU3RyKSB7XG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xuICAgICAgICB2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcy5sZW5ndGggPiAxID8gcGllY2VzWzFdLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcbiAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxiKVwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcXFxifCQpXCIsIFwiZ2lcIiksIFwiIFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvYXR0cmlidXRlcy9hZGRpbmctcmVtb3ZpbmctYW5kLXRlc3RpbmctZm9yLWNsYXNzZXMtOS9cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QgPyBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSA6IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xhc3NOYW1lICsgXCJcXFxcYlwiKS50ZXN0KGVsLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvc2Nyb2xsWSNOb3Rlc1xuICAgIGZ1bmN0aW9uIGdldFBhZ2VPZmZzZXQoZG9jKSB7XG4gICAgICAgIHZhciBzdXBwb3J0UGFnZU9mZnNldCA9IHdpbmRvdy5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXNDU1MxQ29tcGF0ID0gKGRvYy5jb21wYXRNb2RlIHx8IFwiXCIpID09PSBcIkNTUzFDb21wYXRcIjtcbiAgICAgICAgdmFyIHggPSBzdXBwb3J0UGFnZU9mZnNldFxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgICAgICA6IGRvYy5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gc3VwcG9ydFBhZ2VPZmZzZXRcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICA6IGlzQ1NTMUNvbXBhdFxuICAgICAgICAgICAgICAgID8gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICA6IGRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyB3ZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gY29tcHV0ZSBjb25zdGFudHMgaW5zdGVhZFxuICAgIC8vIG9mIGFjY2Vzc2luZyB3aW5kb3cuKiBhcyBzb29uIGFzIHRoZSBtb2R1bGUgbmVlZHMgaXRcbiAgICAvLyBzbyB0aGF0IHdlIGRvIG5vdCBjb21wdXRlIGFueXRoaW5nIGlmIG5vdCBuZWVkZWRcbiAgICBmdW5jdGlvbiBnZXRBY3Rpb25zKCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XG4gICAgICAgIC8vIGEgcHJlZml4LCB3aGljaCBicmVha3MgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBJRTEwIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFwicG9pbnRlcmRvd25cIixcbiAgICAgICAgICAgICAgICBtb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gICAgICAgICAgICAgICAgZW5kOiBcInBvaW50ZXJ1cFwiLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwiTVNQb2ludGVyRG93blwiLFxuICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCIsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIm1vdXNlbW92ZSB0b3VjaG1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZFxuICAgIC8vIElzc3VlICM3ODVcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XG4gICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgIH1cbiAgICAvL2VuZHJlZ2lvblxuICAgIC8vcmVnaW9uIFJhbmdlIENhbGN1bGF0aW9uXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cbiAgICBmdW5jdGlvbiBzdWJSYW5nZVJhdGlvKHBhLCBwYikge1xuICAgICAgICByZXR1cm4gMTAwIC8gKHBiIC0gcGEpO1xuICAgIH1cbiAgICAvLyAocGVyY2VudGFnZSkgSG93IG1hbnkgcGVyY2VudCBpcyB0aGlzIHZhbHVlIG9mIHRoaXMgcmFuZ2U/XG4gICAgZnVuY3Rpb24gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlLCBzdGFydFJhbmdlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAxMDApIC8gKHJhbmdlW3N0YXJ0UmFuZ2UgKyAxXSAtIHJhbmdlW3N0YXJ0UmFuZ2VdKTtcbiAgICB9XG4gICAgLy8gKHBlcmNlbnRhZ2UpIFdoZXJlIGlzIHRoaXMgdmFsdWUgb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmcm9tUGVyY2VudGFnZShyYW5nZSwgcmFuZ2VbMF0gPCAwID8gdmFsdWUgKyBNYXRoLmFicyhyYW5nZVswXSkgOiB2YWx1ZSAtIHJhbmdlWzBdLCAwKTtcbiAgICB9XG4gICAgLy8gKHZhbHVlKSBIb3cgbXVjaCBpcyB0aGlzIHBlcmNlbnRhZ2Ugb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBpc1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEoodmFsdWUsIGFycikge1xuICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSBhcnJbal0pIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgLy8gKHBlcmNlbnRhZ2UpIElucHV0IGEgdmFsdWUsIGZpbmQgd2hlcmUsIG9uIGEgc2NhbGUgb2YgMC0xMDAsIGl0IGFwcGxpZXMuXG4gICAgZnVuY3Rpb24gdG9TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPj0geFZhbC5zbGljZSgtMSlbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4VmFsKTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuICAgICAgICByZXR1cm4gcGEgKyB0b1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sIHZhbHVlKSAvIHN1YlJhbmdlUmF0aW8ocGEsIHBiKTtcbiAgICB9XG4gICAgLy8gKHZhbHVlKSBJbnB1dCBhIHBlcmNlbnRhZ2UsIGZpbmQgd2hlcmUgaXQgaXMgb24gdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICBmdW5jdGlvbiBmcm9tU3RlcHBpbmcoeFZhbCwgeFBjdCwgdmFsdWUpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmFuZ2UgZ3JvdXAgdGhhdCBmaXRzIDEwMFxuICAgICAgICBpZiAodmFsdWUgPj0gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvKHBhLCBwYikpO1xuICAgIH1cbiAgICAvLyAocGVyY2VudGFnZSkgR2V0IHRoZSBzdGVwIHRoYXQgYXBwbGllcyBhdCBhIGNlcnRhaW4gdmFsdWUuXG4gICAgZnVuY3Rpb24gZ2V0U3RlcCh4UGN0LCB4U3RlcHMsIHNuYXAsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIGIgPSB4UGN0W2pdO1xuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF4U3RlcHNbaiAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhQY3RbaiAtIDFdICsgY2xvc2VzdCh2YWx1ZSAtIHhQY3RbaiAtIDFdLCB4U3RlcHNbaiAtIDFdKTtcbiAgICB9XG4gICAgLy9lbmRyZWdpb25cbiAgICAvL3JlZ2lvbiBTcGVjdHJ1bVxuICAgIHZhciBTcGVjdHJ1bSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3BlY3RydW0oZW50cnksIHNuYXAsIHNpbmdsZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMueFBjdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy54VmFsID0gW107XG4gICAgICAgICAgICB0aGlzLnhTdGVwcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcbiAgICAgICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xuICAgICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbZmFsc2VdO1xuICAgICAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHZhciBvcmRlcmVkID0gW107XG4gICAgICAgICAgICAvLyBNYXAgdGhlIG9iamVjdCBrZXlzIHRvIGFuIGFycmF5LlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKFthc0FycmF5KGVudHJ5W2luZGV4XSksIGluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBhY3R1YWwgc3RlcCB2YWx1ZXMuXG4gICAgICAgICAgICAvLyB4U3RlcHMgaXMgc29ydGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHhQY3QgYW5kIHhWYWwuXG4gICAgICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApO1xuICAgICAgICAgICAgLy8gQ29udmVydCBhbGwgbnVtZXJpYyBzdGVwcyB0byB0aGUgcGVyY2VudGFnZSBvZiB0aGUgc3VicmFuZ2UgdGhleSByZXByZXNlbnQuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvdmVyIHRoZSB3aG9sZSBzY2FsZSBvZiByYW5nZXMuXG4gICAgICAgIC8vIGRpcmVjdGlvbjogMCA9IGJhY2t3YXJkcyAvIDEgPSBmb3J3YXJkc1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGlzdGFuY2VzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB4UGN0X2luZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByYW5nZSB3aGVyZSB0byBzdGFydCBjYWxjdWxhdGlvblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy54UGN0W3RoaXMueFBjdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA+IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFBjdF9pbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgeFBjdF9pbmRleCA9IHRoaXMueFBjdC5sZW5ndGggLSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbG9va2luZyBiYWNrd2FyZHMgYW5kIHRoZSB2YWx1ZSBpcyBleGFjdGx5IGF0IGEgcmFuZ2Ugc2VwYXJhdG9yIHRoZW4gbG9vayBvbmUgcmFuZ2UgZnVydGhlclxuICAgICAgICAgICAgaWYgKCFkaXJlY3Rpb24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRfZmFjdG9yO1xuICAgICAgICAgICAgdmFyIHJlc3RfZmFjdG9yID0gMTtcbiAgICAgICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcbiAgICAgICAgICAgIHZhciByYW5nZV9wY3QgPSAwO1xuICAgICAgICAgICAgdmFyIHJlbF9yYW5nZV9kaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB2YXIgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIHJhbmdlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHdoYXQgcGFydCBvZiB0aGUgc3RhcnQgcmFuZ2UgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gKHZhbHVlIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKSAvICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9ICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdmFsdWUpIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gdW50aWwgdGhlIGNvbXBsZXRlIGRpc3RhbmNlIGFjcm9zcyByYW5nZXMgaXMgY2FsY3VsYXRlZFxuICAgICAgICAgICAgd2hpbGUgKHJlc3RfcmVsX2Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiB0b3RhbCByYW5nZVxuICAgICAgICAgICAgICAgIHJhbmdlX3BjdCA9IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMSArIHJhbmdlX2NvdW50ZXJdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXTtcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIG1hcmdpbiwgcGFkZGluZyBvciBsaW1pdCBpcyBsYXJnZXIgdGhlbiB0aGUgY3VycmVudCByYW5nZSBhbmQgY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvciArIDEwMCAtIHN0YXJ0X2ZhY3RvciAqIDEwMCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBsYXJnZXIgdGhlbiB0YWtlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG9mIHRoZSB3aG9sZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3QgZmFjdG9yIG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICByZXN0X2ZhY3RvciA9IChyZXN0X3JlbF9kaXN0YW5jZSAtIDEwMCAqIHN0YXJ0X2ZhY3RvcikgLyBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc3RhcnQgZmFjdG9yIHRvIDEgYXMgZm9yIG5leHQgcmFuZ2UgaXQgZG9lcyBub3QgYXBwbHkuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzbWFsbGVyIG9yIGVxdWFsIHRoZW4gdGFrZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvZiB0aGUgY2FsY3VsYXRlIHBlcmNlbnR1YWwgcGFydCBvZiB0aGF0IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHJlbF9yYW5nZV9kaXN0YW5jZSA9ICgoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJhbmdlX3BjdCkgLyAxMDApICogcmVzdF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3QgbGVmdCBhcyB0aGUgcmVzdCBmaXRzIGluIGN1cnJlbnQgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdF9mYWN0b3IgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgLSByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbWl0IHJhbmdlIHRvIGZpcnN0IHJhbmdlIHdoZW4gZGlzdGFuY2UgYmVjb21lcyBvdXRzaWRlIG9mIG1pbmltdW0gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMueFBjdC5sZW5ndGggKyByYW5nZV9jb3VudGVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciArIHJlbF9yYW5nZV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gbGFzdCByYW5nZSB3aGVuIGRpc3RhbmNlIGJlY29tZXMgb3V0c2lkZSBvZiBtYXhpbXVtIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoIC0gcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZV9jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzdCBvZiByZWxhdGl2ZSBwZXJjZW50dWFsIGRpc3RhbmNlIHN0aWxsIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIGFic19kaXN0YW5jZV9jb3VudGVyO1xuICAgICAgICB9O1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUudG9TdGVwcGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5mcm9tU3RlcHBpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RlcHBpbmcodGhpcy54VmFsLCB0aGlzLnhQY3QsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldFN0ZXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0U3RlcCh0aGlzLnhQY3QsIHRoaXMueFN0ZXBzLCB0aGlzLnNuYXAsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldERlZmF1bHRTdGVwID0gZnVuY3Rpb24gKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcbiAgICAgICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgdGhpcy54UGN0KTtcbiAgICAgICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMTAwIHx8IChpc0Rvd24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFtqIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgaiA9IE1hdGgubWF4KGogLSAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy54VmFsW2pdIC0gdGhpcy54VmFsW2ogLSAxXSkgLyBzaXplO1xuICAgICAgICB9O1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0TmVhcmJ5U3RlcHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgdGhpcy54UGN0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RlcEJlZm9yZToge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDJdLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ogLSAyXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXNTdGVwOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDFdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcEFmdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqXSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbal0sXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2pdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gdGhpcy54TnVtU3RlcHMubWFwKGNvdW50RGVjaW1hbHMpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHN0ZXBEZWNpbWFscyk7XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5oYXNOb1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54VmFsWzBdID09PSB0aGlzLnhWYWxbdGhpcy54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBPdXRzaWRlIHRlc3RpbmdcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5oYW5kbGVFbnRyeVBvaW50ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgICAvLyBDb3ZlcnQgbWluL21heCBzeW50YXggdG8gMCBhbmQgMTAwLlxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cbiAgICAgICAgICAgIGlmICghaXNOdW1lcmljKHBlcmNlbnRhZ2UpIHx8ICFpc051bWVyaWModmFsdWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3JhbmdlJyB2YWx1ZSBpc24ndCBudW1lcmljLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHZhbHVlcy5cbiAgICAgICAgICAgIHRoaXMueFBjdC5wdXNoKHBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgdGhpcy54VmFsLnB1c2godmFsdWVbMF0pO1xuICAgICAgICAgICAgdmFyIHZhbHVlMSA9IE51bWJlcih2YWx1ZVsxXSk7XG4gICAgICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXG4gICAgICAgICAgICAvLyBsb2dnaW5nIGNsZWFyLCBzZXQgc3RlcCBleHBsaWNpdGx5LiBNYWtlIHN1cmVcbiAgICAgICAgICAgIC8vIG5vdCB0byBvdmVycmlkZSB0aGUgJ3N0ZXAnIHNldHRpbmcgd2l0aCBmYWxzZS5cbiAgICAgICAgICAgIGlmICghcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnhTdGVwc1swXSA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhTdGVwcy5wdXNoKGlzTmFOKHZhbHVlMSkgPyBmYWxzZSA6IHZhbHVlMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5oYW5kbGVTdGVwUG9pbnQgPSBmdW5jdGlvbiAoaSwgbikge1xuICAgICAgICAgICAgLy8gSWdub3JlICdmYWxzZScgc3RlcHBpbmcuXG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnhWYWxbaV0gPT09IHRoaXMueFZhbFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhTdGVwc1tpXSA9IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSB0aGlzLnhWYWxbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFjdG9yIHRvIHJhbmdlIHJhdGlvXG4gICAgICAgICAgICB0aGlzLnhTdGVwc1tpXSA9XG4gICAgICAgICAgICAgICAgZnJvbVBlcmNlbnRhZ2UoW3RoaXMueFZhbFtpXSwgdGhpcy54VmFsW2kgKyAxXV0sIG4sIDApIC8gc3ViUmFuZ2VSYXRpbyh0aGlzLnhQY3RbaV0sIHRoaXMueFBjdFtpICsgMV0pO1xuICAgICAgICAgICAgdmFyIHRvdGFsU3RlcHMgPSAodGhpcy54VmFsW2kgKyAxXSAtIHRoaXMueFZhbFtpXSkgLyB0aGlzLnhOdW1TdGVwc1tpXTtcbiAgICAgICAgICAgIHZhciBoaWdoZXN0U3RlcCA9IE1hdGguY2VpbChOdW1iZXIodG90YWxTdGVwcy50b0ZpeGVkKDMpKSAtIDEpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnhWYWxbaV0gKyB0aGlzLnhOdW1TdGVwc1tpXSAqIGhpZ2hlc3RTdGVwO1xuICAgICAgICAgICAgdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHN0ZXA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcGVjdHJ1bTtcbiAgICB9KCkpO1xuICAgIC8vZW5kcmVnaW9uXG4gICAgLy9yZWdpb24gT3B0aW9uc1xuICAgIC8qXHRFdmVyeSBpbnB1dCBvcHRpb24gaXMgdGVzdGVkIGFuZCBwYXJzZWQuIFRoaXMgd2lsbCBwcmV2ZW50XG4gICAgICAgIGVuZGxlc3MgdmFsaWRhdGlvbiBpbiBpbnRlcm5hbCBtZXRob2RzLiBUaGVzZSB0ZXN0cyBhcmVcbiAgICAgICAgc3RydWN0dXJlZCB3aXRoIGFuIGl0ZW0gZm9yIGV2ZXJ5IG9wdGlvbiBhdmFpbGFibGUuIEFuXG4gICAgICAgIG9wdGlvbiBjYW4gYmUgbWFya2VkIGFzIHJlcXVpcmVkIGJ5IHNldHRpbmcgdGhlICdyJyBmbGFnLlxuICAgICAgICBUaGUgdGVzdGluZyBmdW5jdGlvbiBpcyBwcm92aWRlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgICAgICAgIC0gVGhlIHByb3ZpZGVkIHZhbHVlIGZvciB0aGUgb3B0aW9uO1xuICAgICAgICAgICAgLSBBIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Q7XG4gICAgICAgICAgICAtIFRoZSBuYW1lIGZvciB0aGUgb3B0aW9uO1xuXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIHJldHVybnMgZmFsc2Ugd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCxcbiAgICAgICAgb3IgdHJ1ZSB3aGVuIGV2ZXJ5dGhpbmcgaXMgT0suIEl0IGNhbiBhbHNvIG1vZGlmeSB0aGUgb3B0aW9uXG4gICAgICAgIG9iamVjdCwgdG8gbWFrZSBzdXJlIGFsbCB2YWx1ZXMgY2FuIGJlIGNvcnJlY3RseSBsb29wZWQgZWxzZXdoZXJlLiAqL1xuICAgIC8vcmVnaW9uIERlZmF1bHRzXG4gICAgdmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSB7XG4gICAgICAgIHRvOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb206IE51bWJlcixcbiAgICB9O1xuICAgIHZhciBjc3NDbGFzc2VzID0ge1xuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIGJhc2U6IFwiYmFzZVwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcbiAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXG4gICAgICAgIGhhbmRsZVVwcGVyOiBcImhhbmRsZS11cHBlclwiLFxuICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxuICAgICAgICBob3Jpem9udGFsOiBcImhvcml6b250YWxcIixcbiAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbm5lY3Q6IFwiY29ubmVjdFwiLFxuICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxuICAgICAgICBsdHI6IFwibHRyXCIsXG4gICAgICAgIHJ0bDogXCJydGxcIixcbiAgICAgICAgdGV4dERpcmVjdGlvbkx0cjogXCJ0eHQtZGlyLWx0clwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uUnRsOiBcInR4dC1kaXItcnRsXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXG4gICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcbiAgICAgICAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcbiAgICAgICAgcGlwczogXCJwaXBzXCIsXG4gICAgICAgIHBpcHNIb3Jpem9udGFsOiBcInBpcHMtaG9yaXpvbnRhbFwiLFxuICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXG4gICAgICAgIG1hcmtlckhvcml6b250YWw6IFwibWFya2VyLWhvcml6b250YWxcIixcbiAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXG4gICAgICAgIG1hcmtlckxhcmdlOiBcIm1hcmtlci1sYXJnZVwiLFxuICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6IFwidmFsdWUtaG9yaXpvbnRhbFwiLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXG4gICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxuICAgICAgICB2YWx1ZUxhcmdlOiBcInZhbHVlLWxhcmdlXCIsXG4gICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiLFxuICAgIH07XG4gICAgLy8gTmFtZXNwYWNlcyBvZiBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgICB2YXIgSU5URVJOQUxfRVZFTlRfTlMgPSB7XG4gICAgICAgIHRvb2x0aXBzOiBcIi5fX3Rvb2x0aXBzXCIsXG4gICAgICAgIGFyaWE6IFwiLl9fYXJpYVwiLFxuICAgIH07XG4gICAgLy9lbmRyZWdpb25cbiAgICBmdW5jdGlvbiB0ZXN0U3RlcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3N0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc3RlcCBvcHRpb24gY2FuIHN0aWxsIGJlIHVzZWQgdG8gc2V0IHN0ZXBwaW5nXG4gICAgICAgIC8vIGZvciBsaW5lYXIgc2xpZGVycy4gT3ZlcndyaXR0ZW4gaWYgc2V0IGluICdyYW5nZScuXG4gICAgICAgIHBhcnNlZC5zaW5nbGVTdGVwID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RLZXlib2FyZFBhZ2VNdWx0aXBsaWVyKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFBhZ2VNdWx0aXBsaWVyID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RLZXlib2FyZE11bHRpcGxpZXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZE11bHRpcGxpZXInIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQua2V5Ym9hcmRNdWx0aXBsaWVyID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RLZXlib2FyZERlZmF1bHRTdGVwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5rZXlib2FyZERlZmF1bHRTdGVwID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RSYW5nZShwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIEZpbHRlciBpbmNvcnJlY3QgaW5wdXQuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IHVuZGVmaW5lZCB8fCBlbnRyeS5tYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogTWlzc2luZyAnbWluJyBvciAnbWF4JyBpbiAncmFuZ2UnLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuc3BlY3RydW0gPSBuZXcgU3BlY3RydW0oZW50cnksIHBhcnNlZC5zbmFwIHx8IGZhbHNlLCBwYXJzZWQuc2luZ2xlU3RlcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdGFydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0LiBWYWx1ZXMgYXJlbid0IHRlc3RlZCwgYXMgdGhlIHB1YmxpYyAudmFsIG1ldGhvZFxuICAgICAgICAvLyB3aWxsIGFsd2F5cyBwcm92aWRlIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3N0YXJ0JyBvcHRpb24gaXMgaW5jb3JyZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgbnVtYmVyIG9mIGhhbmRsZXMuXG4gICAgICAgIHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xuICAgICAgICAvLyBXaGVuIHRoZSBzbGlkZXIgaXMgaW5pdGlhbGl6ZWQsIHRoZSAudmFsIG1ldGhvZCB3aWxsXG4gICAgICAgIC8vIGJlIGNhbGxlZCB3aXRoIHRoZSBzdGFydCBvcHRpb25zLlxuICAgICAgICBwYXJzZWQuc3RhcnQgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFNuYXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxuICAgICAgICBwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuYW5pbWF0aW9uRHVyYXRpb24gPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdENvbm5lY3QocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICB2YXIgY29ubmVjdCA9IFtmYWxzZV07XG4gICAgICAgIHZhciBpO1xuICAgICAgICAvLyBNYXAgbGVnYWN5IG9wdGlvbnNcbiAgICAgICAgaWYgKGVudHJ5ID09PSBcImxvd2VyXCIpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeSA9PT0gXCJ1cHBlclwiKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xuICAgICAgICBpZiAoZW50cnkgPT09IHRydWUgfHwgZW50cnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0LnB1c2goZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoIHx8IGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMgKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3QgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuY29ubmVjdCA9IGNvbm5lY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBvcmllbnRhdGlvbiB0byBhbiBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeVxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQub3J0ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdE1hcmdpbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXNzdWUgIzU4MlxuICAgICAgICBpZiAoZW50cnkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQubWFyZ2luID0gcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdExpbWl0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnbGltaXQnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5saW1pdCA9IHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeSk7XG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2xpbWl0JyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMgd2l0aCAyIG9yIG1vcmUgaGFuZGxlcy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFBhZGRpbmcocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSAmJiAhQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkgJiYgIShlbnRyeS5sZW5ndGggPT09IDIgfHwgaXNOdW1lcmljKGVudHJ5WzBdKSB8fCBpc051bWVyaWMoZW50cnlbMV0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMgb3IgYXJyYXkgb2YgZXhhY3RseSAyIG51bWJlcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW2VudHJ5LCBlbnRyeV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gJ2dldERpc3RhbmNlJyByZXR1cm5zIGZhbHNlIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgcGFyc2VkLnBhZGRpbmcgPSBbcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzBdKSwgcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzFdKV07XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnNlZC5zcGVjdHJ1bS54TnVtU3RlcHMubGVuZ3RoIC0gMTsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gbGFzdCBcInJhbmdlXCIgY2FuJ3QgY29udGFpbiBzdGVwIHNpemUgYXMgaXQgaXMgcHVyZWx5IGFuIGVuZHBvaW50LlxuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdW2luZGV4XSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV1baW5kZXhdIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcihzKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsUGFkZGluZyA9IGVudHJ5WzBdICsgZW50cnlbMV07XG4gICAgICAgIHZhciBmaXJzdFZhbHVlID0gcGFyc2VkLnNwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFtwYXJzZWQuc3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRvdGFsUGFkZGluZyAvIChsYXN0VmFsdWUgLSBmaXJzdFZhbHVlKSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBub3QgZXhjZWVkIDEwMCUgb2YgdGhlIHJhbmdlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0RGlyZWN0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gU2V0IGRpcmVjdGlvbiBhcyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeSBwYXJzaW5nLlxuICAgICAgICAvLyBJbnZlcnQgY29ubmVjdGlvbiBmb3IgUlRMIHNsaWRlcnMsIHNvIHRoYXQgdGhlIHByb3BlclxuICAgICAgICAvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsdHJcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydGxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEJlaGF2aW91cihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgYSBzdHJpbmcuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGFueSBrZXl3b3Jkcy5cbiAgICAgICAgLy8gTm9uZSBhcmUgcmVxdWlyZWQuXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XG4gICAgICAgIHZhciBkcmFnID0gZW50cnkuaW5kZXhPZihcImRyYWdcIikgPj0gMDtcbiAgICAgICAgdmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZihcImZpeGVkXCIpID49IDA7XG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGhvdmVyID0gZW50cnkuaW5kZXhPZihcImhvdmVyXCIpID49IDA7XG4gICAgICAgIHZhciB1bmNvbnN0cmFpbmVkID0gZW50cnkuaW5kZXhPZihcInVuY29uc3RyYWluZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWdBbGwgPSBlbnRyeS5pbmRleE9mKFwiZHJhZy1hbGxcIikgPj0gMDtcbiAgICAgICAgdmFyIHNtb290aFN0ZXBzID0gZW50cnkuaW5kZXhPZihcInNtb290aC1zdGVwc1wiKSA+PSAwO1xuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdmaXhlZCcgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoIDIgaGFuZGxlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBtYXJnaW4gdG8gZW5mb3JjZSBmaXhlZCBzdGF0ZVxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuY29uc3RyYWluZWQgJiYgKHBhcnNlZC5tYXJnaW4gfHwgcGFyc2VkLmxpbWl0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3VuY29uc3RyYWluZWQnIGJlaGF2aW91ciBjYW5ub3QgYmUgdXNlZCB3aXRoIG1hcmdpbiBvciBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuZXZlbnRzID0ge1xuICAgICAgICAgICAgdGFwOiB0YXAgfHwgc25hcCxcbiAgICAgICAgICAgIGRyYWc6IGRyYWcsXG4gICAgICAgICAgICBkcmFnQWxsOiBkcmFnQWxsLFxuICAgICAgICAgICAgc21vb3RoU3RlcHM6IHNtb290aFN0ZXBzLFxuICAgICAgICAgICAgZml4ZWQ6IGZpeGVkLFxuICAgICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICAgIGhvdmVyOiBob3ZlcixcbiAgICAgICAgICAgIHVuY29uc3RyYWluZWQ6IHVuY29uc3RyYWluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RUb29sdGlwcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnkgPT09IHRydWUgfHwgaXNWYWxpZFBhcnRpYWxGb3JtYXR0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6IG11c3QgcGFzcyBhIGZvcm1hdHRlciBmb3IgYWxsIGhhbmRsZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09IFwiYm9vbGVhblwiICYmICFpc1ZhbGlkUGFydGlhbEZvcm1hdHRlcihmb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd0b29sdGlwcycgbXVzdCBiZSBwYXNzZWQgYSBmb3JtYXR0ZXIgb3IgJ2ZhbHNlJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0SGFuZGxlQXR0cmlidXRlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBtdXN0IHBhc3MgYSBhdHRyaWJ1dGVzIGZvciBhbGwgaGFuZGxlcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmhhbmRsZUF0dHJpYnV0ZXMgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEFyaWFGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2FyaWFGb3JtYXQnIHJlcXVpcmVzICd0bycgbWV0aG9kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuYXJpYUZvcm1hdCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2Zvcm1hdCcgcmVxdWlyZXMgJ3RvJyBhbmQgJ2Zyb20nIG1ldGhvZHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5mb3JtYXQgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkU3VwcG9ydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAna2V5Ym9hcmRTdXBwb3J0JyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdERvY3VtZW50RWxlbWVudChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYWR2YW5jZWQgb3B0aW9uLiBQYXNzZWQgdmFsdWVzIGFyZSB1c2VkIHdpdGhvdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0Q3NzUHJlZml4KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdjc3NQcmVmaXgnIG11c3QgYmUgYSBzdHJpbmcgb3IgYGZhbHNlYC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmNzc1ByZWZpeCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0Q3NzQ2xhc3NlcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuY3NzUHJlZml4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5jc3NDbGFzc2VzW2tleV0gPSBwYXJzZWQuY3NzUHJlZml4ICsgZW50cnlba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUZXN0IGFsbCBkZXZlbG9wZXIgc2V0dGluZ3MgYW5kIHBhcnNlIHRvIGFzc3VtcHRpb24tc2FmZSB2YWx1ZXMuXG4gICAgZnVuY3Rpb24gdGVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAvLyBUbyBwcm92ZSBhIGZpeCBmb3IgIzUzNywgZnJlZXplIG9wdGlvbnMgaGVyZS5cbiAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpcyBtb2RpZmllZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICAgIC8vIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgICBtYXJnaW46IG51bGwsXG4gICAgICAgICAgICBsaW1pdDogbnVsbCxcbiAgICAgICAgICAgIHBhZGRpbmc6IG51bGwsXG4gICAgICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRlc3RzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJlc2VudGVkIGhlcmUuXG4gICAgICAgIHZhciB0ZXN0cyA9IHtcbiAgICAgICAgICAgIHN0ZXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RTdGVwIH0sXG4gICAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiB7IHI6IGZhbHNlLCB0OiB0ZXN0S2V5Ym9hcmRQYWdlTXVsdGlwbGllciB9LFxuICAgICAgICAgICAga2V5Ym9hcmRNdWx0aXBsaWVyOiB7IHI6IGZhbHNlLCB0OiB0ZXN0S2V5Ym9hcmRNdWx0aXBsaWVyIH0sXG4gICAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0S2V5Ym9hcmREZWZhdWx0U3RlcCB9LFxuICAgICAgICAgICAgc3RhcnQ6IHsgcjogdHJ1ZSwgdDogdGVzdFN0YXJ0IH0sXG4gICAgICAgICAgICBjb25uZWN0OiB7IHI6IHRydWUsIHQ6IHRlc3RDb25uZWN0IH0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxuICAgICAgICAgICAgc25hcDogeyByOiBmYWxzZSwgdDogdGVzdFNuYXAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgcjogZmFsc2UsIHQ6IHRlc3RBbmltYXRlIH0sXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXG4gICAgICAgICAgICByYW5nZTogeyByOiB0cnVlLCB0OiB0ZXN0UmFuZ2UgfSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0T3JpZW50YXRpb24gfSxcbiAgICAgICAgICAgIG1hcmdpbjogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxuICAgICAgICAgICAgbGltaXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RMaW1pdCB9LFxuICAgICAgICAgICAgcGFkZGluZzogeyByOiBmYWxzZSwgdDogdGVzdFBhZGRpbmcgfSxcbiAgICAgICAgICAgIGJlaGF2aW91cjogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXG4gICAgICAgICAgICBhcmlhRm9ybWF0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0QXJpYUZvcm1hdCB9LFxuICAgICAgICAgICAgZm9ybWF0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0Rm9ybWF0IH0sXG4gICAgICAgICAgICB0b29sdGlwczogeyByOiBmYWxzZSwgdDogdGVzdFRvb2x0aXBzIH0sXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHsgcjogdHJ1ZSwgdDogdGVzdEtleWJvYXJkU3VwcG9ydCB9LFxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50OiB7IHI6IGZhbHNlLCB0OiB0ZXN0RG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgICAgICBjc3NQcmVmaXg6IHsgcjogdHJ1ZSwgdDogdGVzdENzc1ByZWZpeCB9LFxuICAgICAgICAgICAgY3NzQ2xhc3NlczogeyByOiB0cnVlLCB0OiB0ZXN0Q3NzQ2xhc3NlcyB9LFxuICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlczogeyByOiBmYWxzZSwgdDogdGVzdEhhbmRsZUF0dHJpYnV0ZXMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY29ubmVjdDogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBiZWhhdmlvdXI6IFwidGFwXCIsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgICBjc3NQcmVmaXg6IFwibm9VaS1cIixcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxuICAgICAgICAgICAga2V5Ym9hcmRNdWx0aXBsaWVyOiAxLFxuICAgICAgICAgICAga2V5Ym9hcmREZWZhdWx0U3RlcDogMTAsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFyaWFGb3JtYXQgZGVmYXVsdHMgdG8gcmVndWxhciBmb3JtYXQsIGlmIGFueS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYXJpYUZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biBhbGwgb3B0aW9ucyB0aHJvdWdoIGEgdGVzdGluZyBtZWNoYW5pc20gdG8gZW5zdXJlIGNvcnJlY3RcbiAgICAgICAgLy8gaW5wdXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IG9wdGlvbnMgbWlnaHQgZ2V0IG1vZGlmaWVkIHRvXG4gICAgICAgIC8vIGJlIGhhbmRsZWQgcHJvcGVybHkuIEUuZy4gd3JhcHBpbmcgaW50ZWdlcnMgaW4gYXJyYXlzLlxuICAgICAgICBPYmplY3Qua2V5cyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpc24ndCBzZXQsIGJ1dCBpdCBpcyByZXF1aXJlZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBpZiAoIWlzU2V0KG9wdGlvbnNbbmFtZV0pICYmIGRlZmF1bHRzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdHNbbmFtZV0ucikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVzdHNbbmFtZV0udChwYXJzZWQsICFpc1NldChvcHRpb25zW25hbWVdKSA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGb3J3YXJkIHBpcHMgb3B0aW9uc1xuICAgICAgICBwYXJzZWQucGlwcyA9IG9wdGlvbnMucGlwcztcbiAgICAgICAgLy8gQWxsIHJlY2VudCBicm93c2VycyBhY2NlcHQgdW5wcmVmaXhlZCB0cmFuc2Zvcm0uXG4gICAgICAgIC8vIFdlIG5lZWQgLW1zLSBmb3IgSUU5IGFuZCAtd2Via2l0LSBmb3Igb2xkZXIgQW5kcm9pZDtcbiAgICAgICAgLy8gQXNzdW1lIHVzZSBvZiAtd2Via2l0LSBpZiB1bnByZWZpeGVkIGFuZCAtbXMtIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PXRyYW5zZm9ybXMyZFxuICAgICAgICB2YXIgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBtc1ByZWZpeCA9IGQuc3R5bGUubXNUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG5vUHJlZml4ID0gZC5zdHlsZS50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyc2VkLnRyYW5zZm9ybVJ1bGUgPSBub1ByZWZpeCA/IFwidHJhbnNmb3JtXCIgOiBtc1ByZWZpeCA/IFwibXNUcmFuc2Zvcm1cIiA6IFwid2Via2l0VHJhbnNmb3JtXCI7XG4gICAgICAgIC8vIFBpcHMgZG9uJ3QgbW92ZSwgc28gd2UgY2FuIHBsYWNlIHRoZW0gdXNpbmcgbGVmdC90b3AuXG4gICAgICAgIHZhciBzdHlsZXMgPSBbXG4gICAgICAgICAgICBbXCJsZWZ0XCIsIFwidG9wXCJdLFxuICAgICAgICAgICAgW1wicmlnaHRcIiwgXCJib3R0b21cIl0sXG4gICAgICAgIF07XG4gICAgICAgIHBhcnNlZC5zdHlsZSA9IHN0eWxlc1twYXJzZWQuZGlyXVtwYXJzZWQub3J0XTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgLy9lbmRyZWdpb25cbiAgICBmdW5jdGlvbiBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICAgICAgdmFyIHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lID0gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKTtcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lICYmIGdldFN1cHBvcnRzUGFzc2l2ZSgpO1xuICAgICAgICAvLyBBbGwgdmFyaWFibGVzIGxvY2FsIHRvICdzY29wZScgYXJlIHByZWZpeGVkIHdpdGggJ3Njb3BlXydcbiAgICAgICAgLy8gU2xpZGVyIERPTSBOb2Rlc1xuICAgICAgICB2YXIgc2NvcGVfVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgc2NvcGVfQmFzZTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZXM7XG4gICAgICAgIHZhciBzY29wZV9Db25uZWN0cztcbiAgICAgICAgdmFyIHNjb3BlX1BpcHM7XG4gICAgICAgIHZhciBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgLy8gU2xpZGVyIHN0YXRlIHZhbHVlc1xuICAgICAgICB2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xuICAgICAgICB2YXIgc2NvcGVfVmFsdWVzID0gW107XG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZU51bWJlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9IDA7XG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTtcbiAgICAgICAgLy8gRG9jdW1lbnQgTm9kZXNcbiAgICAgICAgdmFyIHNjb3BlX0RvY3VtZW50ID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHZhciBzY29wZV9Eb2N1bWVudEVsZW1lbnQgPSBvcHRpb25zLmRvY3VtZW50RWxlbWVudCB8fCBzY29wZV9Eb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBzY29wZV9Cb2R5ID0gc2NvcGVfRG9jdW1lbnQuYm9keTtcbiAgICAgICAgLy8gRm9yIGhvcml6b250YWwgc2xpZGVycyBpbiBzdGFuZGFyZCBsdHIgZG9jdW1lbnRzLFxuICAgICAgICAvLyBtYWtlIC5ub1VpLW9yaWdpbiBvdmVyZmxvdyB0byB0aGUgbGVmdCBzbyB0aGUgZG9jdW1lbnQgZG9lc24ndCBzY3JvbGwuXG4gICAgICAgIHZhciBzY29wZV9EaXJPZmZzZXQgPSBzY29wZV9Eb2N1bWVudC5kaXIgPT09IFwicnRsXCIgfHwgb3B0aW9ucy5vcnQgPT09IDEgPyAwIDogMTAwO1xuICAgICAgICAvLyBDcmVhdGVzIGEgbm9kZSwgYWRkcyBpdCB0byB0YXJnZXQsIHJldHVybnMgdGhlIG5ldyBub2RlLlxuICAgICAgICBmdW5jdGlvbiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGRpdiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRhcmdldC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcbiAgICAgICAgZnVuY3Rpb24gYWRkT3JpZ2luKGJhc2UsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMub3JpZ2luKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcbiAgICAgICAgICAgIGFkZE5vZGVUbyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpO1xuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGFuZGxlXCIsIFN0cmluZyhoYW5kbGVOdW1iZXIpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgICAgICAgICAgICAgICAvLyAwID0gZm9jdXNhYmxlIGFuZCByZWFjaGFibGVcbiAgICAgICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZUF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzXzEgPSBvcHRpb25zLmhhbmRsZUF0dHJpYnV0ZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgYXR0cmlidXRlc18xW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzbGlkZXJcIik7XG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBvcHRpb25zLm9ydCA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVMb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVOdW1iZXIgPT09IG9wdGlvbnMuaGFuZGxlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCBub2RlcyBmb3IgY29ubmVjdCBlbGVtZW50c1xuICAgICAgICBmdW5jdGlvbiBhZGRDb25uZWN0KGJhc2UsIGFkZCkge1xuICAgICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKGNvbm5lY3RPcHRpb25zLCBiYXNlKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdEJhc2UgPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmNvbm5lY3RzKTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMgPSBbXTtcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzID0gW107XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zWzBdKSk7XG4gICAgICAgICAgICAvLyBbOjo6Ok89PT09Tz09PT1PPT09PV1cbiAgICAgICAgICAgIC8vIGNvbm5lY3RPcHRpb25zID0gWzAsIDEsIDEsIDFdXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBhIGxpc3Qgb2YgYWxsIGFkZGVkIGhhbmRsZXMuXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5wdXNoKGFkZE9yaWdpbihiYXNlLCBpKSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVyc1tpXSA9IGk7XG4gICAgICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGNvbm5lY3RCYXNlLCBjb25uZWN0T3B0aW9uc1tpICsgMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGEgc2luZ2xlIHNsaWRlci5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGVyKGFkZFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyBhbmQgZGF0YSB0byB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmx0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5ydGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3J0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4dERpcmVjdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoYWRkVGFyZ2V0KS5kaXJlY3Rpb247XG4gICAgICAgICAgICBpZiAodGV4dERpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25SdGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGV4dERpcmVjdGlvbkx0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvb2x0aXAoaGFuZGxlLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwcyB8fCAhb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU2xpZGVyRGlzYWJsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfVGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNsaWRlciBkcmFnZ2luZyBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT3JpZ2luID0gc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9yaWdpbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVUb29sdGlwcygpIHtcbiAgICAgICAgICAgIGlmIChzY29wZV9Ub29sdGlwcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcyk7XG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0b29sdGlwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdG9vbHRpcHMgb3B0aW9uIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBzKCkge1xuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHMoKTtcbiAgICAgICAgICAgIC8vIFRvb2x0aXBzIGFyZSBhZGRlZCB3aXRoIG9wdGlvbnMudG9vbHRpcHMgaW4gb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgICAgICBzY29wZV9Ub29sdGlwcyA9IHNjb3BlX0hhbmRsZXMubWFwKGFkZFRvb2x0aXApO1xuICAgICAgICAgICAgYmluZEV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcywgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlX1Rvb2x0aXBzIHx8ICFvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdmFsdWVzW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXS50byh1bmVuY29kZWRbaGFuZGxlTnVtYmVyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0uaW5uZXJIVE1MID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcmlhKCkge1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLmFyaWEpO1xuICAgICAgICAgICAgYmluZEV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy5hcmlhLCBmdW5jdGlvbiAodmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCwgdGFwLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgQXJpYSBWYWx1ZXMgZm9yIGFsbCBoYW5kbGVzLCBhcyBhIGNoYW5nZSBpbiBvbmUgY2hhbmdlcyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZXh0LlxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGluZGV4LCAwLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMTAwLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdHRlZCB2YWx1ZSBmb3IgZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IFN0cmluZyhvcHRpb25zLmFyaWFGb3JtYXQudG8odW5lbmNvZGVkW2luZGV4XSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdG8gc2xpZGVyIHJhbmdlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWluKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWF4KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBtYXgpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBub3cpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cChwaXBzKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHJhbmdlLlxuICAgICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5SYW5nZSB8fCBwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuU3RlcHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuQ291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlwcy52YWx1ZXMgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICd2YWx1ZXMnICg+PSAyKSByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBwaXBzLnZhbHVlcyAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZCA9IDEwMCAvIGludGVydmFsO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBMaXN0IHRoZXNlIHBhcnRzIGFuZCBoYXZlIHRoZW0gaGFuZGxlZCBhcyAncG9zaXRpb25zJy5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJ2YWwtLSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFRvUmFuZ2UodmFsdWVzLCBwaXBzLnN0ZXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5Qb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXAgYWxsIHBlcmNlbnRhZ2VzIHRvIG9uLXJhbmdlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwVG9SYW5nZShwaXBzLnZhbHVlcywgcGlwcy5zdGVwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIG11c3QgYmUgc3RlcHBlZCwgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgcGVyY2VudGFnZSBmaXJzdC5cbiAgICAgICAgICAgICAgICBpZiAocGlwcy5zdGVwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwaXBzLnZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2UsIGFwcGx5IHN0ZXAsIHJldHVybiB0byB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc2NvcGVfU3BlY3RydW0uZ2V0U3RlcChzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiBwaXBzLnZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gcGlwcy5tb2RlID0gbmV2ZXJcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBUb1JhbmdlKHZhbHVlcywgc3RlcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzdGVwcGVkID8gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVNwcmVhZChwaXBzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBmbG9hdGluZyBwb2ludCB2YXJpYW5jZSBieSBkcm9wcGluZyB0aGUgc21hbGxlc3QgZGVjaW1hbCBwbGFjZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcigodmFsdWUgKyBpbmNyZW1lbnQpLnRvRml4ZWQoNykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ2V0R3JvdXAocGlwcyk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgICAgICB2YXIgbGFzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsW3Njb3BlX1NwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgaWdub3JlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHJldlBjdCA9IDA7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBncm91cCA9IHVuaXF1ZShncm91cC5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJhbmdlIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBncm91cC51bnNoaWZ0KGZpcnN0SW5SYW5nZSk7XG4gICAgICAgICAgICAgICAgaWdub3JlRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlrZXdpc2UgZm9yIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgICAgIGlmIChncm91cFtncm91cC5sZW5ndGggLSAxXSAhPT0gbGFzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBncm91cC5wdXNoKGxhc3RJblJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZ25vcmVMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgYW5kIHRoZSBsb3dlciArIHVwcGVyIHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgcTtcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IGdyb3VwW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIG5ld1BjdDtcbiAgICAgICAgICAgICAgICB2YXIgcGN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgcGN0UG9zO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgICAgICAgICB2YXIgcmVhbFN0ZXBzO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdGVwcyA9IHBpcHMubW9kZSA9PT0gZXhwb3J0cy5QaXBzTW9kZS5TdGVwcztcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nICdzdGVwcycgbW9kZSwgdXNlIHRoZSBwcm92aWRlZCBzdGVwcy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ2xsIHN0ZXAgb24gdG8gdGhlIG5leHQgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLnhOdW1TdGVwc1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gYSAnZnVsbCcgc3RlcC5cbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IGhpZ2ggLSBsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGhpZ2ggaXMgdW5kZWZpbmVkIHdlIGFyZSBhdCB0aGUgbGFzdCBzdWJyYW5nZS4gTWFrZSBzdXJlIGl0IGl0ZXJhdGVzIG9uY2UgKCMxMDg4KVxuICAgICAgICAgICAgICAgIGlmIChoaWdoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IGxvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcbiAgICAgICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIG5ld1BjdCA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcoaSk7XG4gICAgICAgICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xuICAgICAgICAgICAgICAgICAgICBzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyAocGlwcy5kZW5zaXR5IHx8IDEpO1xuICAgICAgICAgICAgICAgICAgICByZWFsU3RlcHMgPSBNYXRoLnJvdW5kKHN0ZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByYXRpbyByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGEgZGVuc2l0eSAxIHRoZSBwb2ludHMvcGVyY2VudGFnZSA9IDEuIEZvciBkZW5zaXR5IDIsIHRoYXQgcGVyY2VudGFnZSBuZWVkcyB0byBiZSByZS1kaXZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgc3RlcFNpemUgPSBwY3REaWZmZXJlbmNlIC8gcmVhbFN0ZXBzO1xuICAgICAgICAgICAgICAgICAgICAvLyBEaXZpZGUgYWxsIHBvaW50cyBldmVubHksIGFkZGluZyB0aGUgY29ycmVjdCBudW1iZXIgdG8gdGhpcyBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDw9IHNvIHRoYXQgMTAwJSBnZXRzIGEgcG9pbnQsIGV2ZW50IGlmIGlnbm9yZUxhc3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAxOyBxIDw9IHJlYWxTdGVwczsgcSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgcm91bmRlZCB2YWx1ZSBhbmQgdGhlIGFjdHVhbCBzaXplIG1pZ2h0IGJlIH4xJSBvZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsbCByYW5nZSwgMiBmb3IgNTAsIDQgZm9yIDI1LCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1twY3RQb3MudG9GaXhlZCg1KV0gPSBbc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHBjdFBvcyksIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgcG9pbnQgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGdyb3VwLmluZGV4T2YoaSkgPiAtMSA/IGV4cG9ydHMuUGlwc1R5cGUuTGFyZ2VWYWx1ZSA6IGlzU3RlcHMgPyBleHBvcnRzLlBpcHNUeXBlLlNtYWxsVmFsdWUgOiBleHBvcnRzLlBpcHNUeXBlLk5vVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZGV4ICYmIGlnbm9yZUZpcnN0ICYmIGkgIT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPT09IGhpZ2ggJiYgaWdub3JlTGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVyY2VudGFnZSBjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgcHJldlBjdCA9IG5ld1BjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNjb3BlX0RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgdmFsdWVTaXplQ2xhc3NlcyA9IChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW2V4cG9ydHMuUGlwc1R5cGUuTm9uZV0gPSBcIlwiLFxuICAgICAgICAgICAgICAgIF9hW2V4cG9ydHMuUGlwc1R5cGUuTm9WYWx1ZV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWwsXG4gICAgICAgICAgICAgICAgX2FbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlLFxuICAgICAgICAgICAgICAgIF9hW2V4cG9ydHMuUGlwc1R5cGUuU21hbGxWYWx1ZV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVTdWIsXG4gICAgICAgICAgICAgICAgX2EpO1xuICAgICAgICAgICAgdmFyIG1hcmtlclNpemVDbGFzc2VzID0gKF9iID0ge30sXG4gICAgICAgICAgICAgICAgX2JbZXhwb3J0cy5QaXBzVHlwZS5Ob25lXSA9IFwiXCIsXG4gICAgICAgICAgICAgICAgX2JbZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJOb3JtYWwsXG4gICAgICAgICAgICAgICAgX2JbZXhwb3J0cy5QaXBzVHlwZS5MYXJnZVZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJMYXJnZSxcbiAgICAgICAgICAgICAgICBfYltleHBvcnRzLlBpcHNUeXBlLlNtYWxsVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclN1YixcbiAgICAgICAgICAgICAgICBfYik7XG4gICAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xuICAgICAgICAgICAgdmFyIG1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMubWFya2VySG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclZlcnRpY2FsXTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gc291cmNlID09PSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uQ2xhc3NlcyA9IGEgPyB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA6IG1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcztcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgKyBcIiBcIiArIG9yaWVudGF0aW9uQ2xhc3Nlc1tvcHRpb25zLm9ydF0gKyBcIiBcIiArIHNpemVDbGFzc2VzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3ByZWFkKG9mZnNldCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgZmlsdGVyIGZ1bmN0aW9uLCBpZiBpdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZpbHRlckZ1bmMgPyBmaWx0ZXJGdW5jKHZhbHVlLCB0eXBlKSA6IHR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuUGlwc1R5cGUuTm9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBhIG1hcmtlciBmb3IgZXZlcnkgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIpO1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZXMgYXJlIG9ubHkgYXBwZW5kZWQgZm9yIHBvaW50cyBtYXJrZWQgJzEnIG9yICcyJy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA+IGV4cG9ydHMuUGlwc1R5cGUuTm9WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IG9mZnNldCArIFwiJVwiO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZyhmb3JtYXR0ZXIudG8odmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgYWxsIHBvaW50cy5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNwcmVhZCkuZm9yRWFjaChmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYWRkU3ByZWFkKG9mZnNldCwgc3ByZWFkW29mZnNldF1bMF0sIHNwcmVhZFtvZmZzZXRdWzFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcbiAgICAgICAgICAgIGlmIChzY29wZV9QaXBzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChzY29wZV9QaXBzKTtcbiAgICAgICAgICAgICAgICBzY29wZV9QaXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwaXBzKHBpcHMpIHtcbiAgICAgICAgICAgIC8vIEZpeCAjNjY5XG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XG4gICAgICAgICAgICB2YXIgc3ByZWFkID0gZ2VuZXJhdGVTcHJlYWQocGlwcyk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gcGlwcy5maWx0ZXI7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gcGlwcy5mb3JtYXQgfHwge1xuICAgICAgICAgICAgICAgIHRvOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1BpcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRoYW5kIGZvciBiYXNlIGRpbWVuc2lvbnMuXG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaXplKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzY29wZV9CYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGFsdCA9IChcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50KGV2ZW50cywgZWxlbWVudCwgY2FsbGJhY2ssIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGZpeEV2ZW50KGV2ZW50LCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGZpeEV2ZW50IHJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBoYXMgYSBkaWZmZXJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG9Ob3RSZWplY3QgaXMgcGFzc2VkIGJ5IGFsbCBlbmQgZXZlbnRzIHRvIG1ha2Ugc3VyZSByZWxlYXNlZCB0b3VjaGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gJ3N1cHBvcnRzUGFzc2l2ZScgaXMgb25seSB0cnVlIGlmIGEgYnJvd3NlciBhbHNvIHN1cHBvcnRzIHRvdWNoLWFjdGlvbjogbm9uZSBpbiBDU1MuXG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBkb2VzIG5vdCwgc28gaXQgZG9lc24ndCBnZXQgdG8gYmVuZWZpdCBmcm9tIHBhc3NpdmUgc2Nyb2xsaW5nLiBpT1MgZG9lcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8gdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24sIGJ1dCB0aGF0IGFsbG93cyBwYW5uaW5nLCB3aGljaCBicmVha3NcbiAgICAgICAgICAgICAgICAvLyBzbGlkZXJzIGFmdGVyIHpvb21pbmcvb24gbm9uLXJlc3BvbnNpdmUgcGFnZXMuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMzMTEyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c1Bhc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmNhbGNQb2ludCA9IGUucG9pbnRzW29wdGlvbnMub3J0XTtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbWV0aG9kLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goW2V2ZW50TmFtZSwgbWV0aG9kXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICBmdW5jdGlvbiBmaXhFdmVudChlLCBwYWdlT2Zmc2V0LCBldmVudFRhcmdldCkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICAvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoZS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVycm9uZW91cyBldmVudHMgc2VlbSB0byBiZSBwYXNzZWQgaW4gb2NjYXNpb25hbGx5IG9uIGlPUy9pUGFkT1MgYWZ0ZXIgdXNlciBmaW5pc2hlcyBpbnRlcmFjdGluZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgc2xpZGVyLiBUaGV5IGFwcGVhciB0byBiZSBvZiB0eXBlIE1vdXNlRXZlbnQsIHlldCB0aGV5IGRvbid0IGhhdmUgdXN1YWwgcHJvcGVydGllcyBzZXQuIElnbm9yZVxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgaGF2ZSBubyB0b3VjaGVzIG9yIGJ1dHRvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZW0uICgjMTA1NywgIzEwNzksICMxMDk1KVxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhZS5idXR0b25zICYmICFlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgb25seSB0aGluZyBvbmUgaGFuZGxlIHNob3VsZCBiZSBjb25jZXJuZWQgYWJvdXQgaXMgdGhlIHRvdWNoZXMgdGhhdCBvcmlnaW5hdGVkIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaE9uVGFyZ2V0ID0gZnVuY3Rpb24gKGNoZWNrVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNoZWNrVG91Y2gudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRhcmdldCA9PT0gZXZlbnRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLmNvbXBvc2VkICYmIGUuY29tcG9zZWRQYXRoKCkuc2hpZnQoKSA9PT0gZXZlbnRUYXJnZXQpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHRvdWNoc3RhcnQgZXZlbnRzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBzdGlsbCBubyBtb3JlIHRoYW4gb25lXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggb24gdGhlIHRhcmdldCBzbyB3ZSBsb29rIGFtb25nc3QgYWxsIHRvdWNoZXMuXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZS50b3VjaGVzLCBpc1RvdWNoT25UYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gb25lIHRvdWNoIHBlciBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCBpZiB0aGUgdGFyZ2V0IHRvdWNoIGhhcyBub3QgbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2gucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaC5wYWdlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KHNjb3BlX0RvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChtb3VzZSB8fCBwb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgeCA9IGUuY2xpZW50WCArIHBhZ2VPZmZzZXQueDtcbiAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wYWdlT2Zmc2V0ID0gcGFnZU9mZnNldDtcbiAgICAgICAgICAgIGUucG9pbnRzID0gW3gsIHldO1xuICAgICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIGEgY29vcmRpbmF0ZSBpbiB0aGUgZG9jdW1lbnQgdG8gYSBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcbiAgICAgICAgZnVuY3Rpb24gY2FsY1BvaW50VG9QZXJjZW50YWdlKGNhbGNQb2ludCkge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IChsb2NhdGlvbiAqIDEwMCkgLyBiYXNlU2l6ZSgpO1xuICAgICAgICAgICAgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxuICAgICAgICAgICAgLy8gT3V0LW9mLWJvdW5kIGNvb3JkaW5hdGVzIG1heSBvY2N1ciB3aGVuIC5ub1VpLWJhc2UgcHNldWRvLWVsZW1lbnRzXG4gICAgICAgICAgICAvLyBhcmUgdXNlZCAoZS5nLiBjb250YWluZWQgaGFuZGxlcyBmZWF0dXJlKVxuICAgICAgICAgICAgcHJvcG9zYWwgPSBsaW1pdChwcm9wb3NhbCk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgaGFuZGxlIGNsb3Nlc3QgdG8gYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SGFuZGxlKGNsaWNrZWRQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHNtYWxsZXN0RGlmZmVyZW5jZSA9IDEwMDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUG9zaXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPSBNYXRoLmFicyhoYW5kbGVQb3NpdGlvbiAtIGNsaWNrZWRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBjbGlja0F0RWRnZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9PT0gMTAwICYmIHNtYWxsZXN0RGlmZmVyZW5jZSA9PT0gMTAwO1xuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB0aGlzIGhhbmRsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzbHkgY2hlY2tlZCBoYW5kbGVcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPCBzbWFsbGVzdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2xvc2VyQWZ0ZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPD0gc21hbGxlc3REaWZmZXJlbmNlICYmIGNsaWNrZWRQb3NpdGlvbiA+IGhhbmRsZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NlciB8fCBpc0Nsb3NlckFmdGVyIHx8IGNsaWNrQXRFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdERpZmZlcmVuY2UgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudExlYXZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG1vdmVtZW50IG9uIGRvY3VtZW50IGZvciBoYW5kbGUgYW5kIHJhbmdlIGRyYWcuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50TW92ZShldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gRml4ICM0OThcbiAgICAgICAgICAgIC8vIENoZWNrIHZhbHVlIG9mIC5idXR0b25zIGluICdzdGFydCcgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUUxMCBtb2JpbGUgKGRhdGEuYnV0dG9uc1Byb3BlcnR5KS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvOTI3MDA1L21vYmlsZS1pZTEwLXdpbmRvd3MtcGhvbmUtYnV0dG9ucy1wcm9wZXJ0eS1vZi1wb2ludGVybW92ZS1ldmVudC1hbHdheXMtemVyb1xuICAgICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxuICAgICAgICAgICAgLy8gRmlyZWZveCBicmVha3MgdGhlIHNwZWMgTUROIGRlZmluZXMuXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZihcIk1TSUUgOVwiKSA9PT0gLTEgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCAmJiBkYXRhLmJ1dHRvbnNQcm9wZXJ0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgbW92aW5nIHVwIG9yIGRvd25cbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBtb3ZlbWVudCBpbnRvIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHdpZHRoL2hlaWdodFxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XG4gICAgICAgICAgICBtb3ZlSGFuZGxlcyhtb3ZlbWVudCA+IDAsIHByb3Bvc2FsLCBkYXRhLmxvY2F0aW9ucywgZGF0YS5oYW5kbGVOdW1iZXJzLCBkYXRhLmNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50RW5kKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhkYXRhLmhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxuICAgICAgICAgICAgZGF0YS5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xuICAgICAgICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCB0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiZW5kXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBldmVudFN0YXJ0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlTnVtYmVycy5zb21lKGlzSGFuZGxlRGlzYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZTtcbiAgICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGVPcmlnaW4uY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgaGFuZGxlIGFzICdhY3RpdmUnIHNvIGl0IGNhbiBiZSBzdHlsZWQuXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIG1vdmUgYW5kIGVuZCBldmVudHMuXG4gICAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBldmVudCB0YXJnZXQgaGFzIGNoYW5nZWQgc28gd2UgbmVlZCB0byBwcm9wYWdhdGUgdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IHdlIGtlZXBcbiAgICAgICAgICAgICAgICAvLyByZWx5aW5nIG9uIGl0IHRvIGV4dHJhY3QgdGFyZ2V0IHRvdWNoZXMuXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdDogZGF0YS5jb25uZWN0LFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q2FsY1BvaW50OiBldmVudC5jYWxjUG9pbnQsXG4gICAgICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplKCksXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBlbmRFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMuZW5kLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50RW5kLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogZGF0YS5oYW5kbGVOdW1iZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGRvTm90UmVqZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAgIC8vIGEgbmV3IG9uZSBhcyBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxuICAgICAgICAgICAgLy8gc28gYWRkaW5nIGN1cnNvciBzdHlsZXMgY2FuIGJlIHNraXBwZWQuXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cbiAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdpdGggYSBkcmFnZ2luZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmcgdGhlIGhhbmRsZXMuXG4gICAgICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIG9ubHkgaG9sZG91dCBpcyBpT1MgU2FmYXJpLiBUaGlzIGRvZXNuJ3QgbWF0dGVyOiB0ZXh0IHNlbGVjdGlvbiBpc24ndCB0cmlnZ2VyZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic3RhcnRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuICAgICAgICBmdW5jdGlvbiBldmVudFRhcChldmVudCkge1xuICAgICAgICAgICAgLy8gVGhlIHRhcCBldmVudCBzaG91bGRuJ3QgcHJvcGFnYXRlIHVwXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xuICAgICAgICAgICAgLy8gVGFja2xlIHRoZSBjYXNlIHRoYXQgYWxsIGhhbmRsZXMgYXJlICdkaXNhYmxlZCcuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRha2VzIGEgY29uZmlndXJhYmxlIGFtb3VudCBvZiBtcyAoZGVmYXVsdCAzMDApLiBSZS1lbmFibGUgdGhlIHNsaWRlciBhZnRlciB0aGF0LlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NGb3Ioc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwLCBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7IGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVzIGEgJ2hvdmVyJyBldmVudCBmb3IgYSBob3ZlcmVkIG1vdXNlL3BlbiBwb3NpdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XG4gICAgICAgICAgICB2YXIgdG8gPSBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHByb3Bvc2FsKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGVfU2VsZiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGVzIGtleWRvd24gb24gZm9jdXNlZCBoYW5kbGVzXG4gICAgICAgIC8vIERvbid0IG1vdmUgdGhlIGRvY3VtZW50IHdoZW4gcHJlc3NpbmcgYXJyb3cga2V5cyBvbiBmb2N1c2VkIGhhbmRsZXNcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgfHwgaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsS2V5cyA9IFtcIkRvd25cIiwgXCJVcFwiXTtcbiAgICAgICAgICAgIHZhciBsYXJnZVN0ZXBLZXlzID0gW1wiUGFnZURvd25cIiwgXCJQYWdlVXBcIl07XG4gICAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xuICAgICAgICAgICAgICAgIC8vIE9uIGFuIHJpZ2h0LXRvLWxlZnQgc2xpZGVyLCB0aGUgbGVmdCBhbmQgcmlnaHQga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsS2V5cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9ydCAmJiAhb3B0aW9ucy5kaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhIHRvcC10by1ib3R0b20gc2xpZGVyLCB0aGUgdXAgYW5kIGRvd24ga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGxhcmdlU3RlcEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXAgXCJBcnJvd1wiIGZvciBJRSBjb21wYXRpYmlsaXR5LiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGlzTGFyZ2VEb3duID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzBdO1xuICAgICAgICAgICAgdmFyIGlzTGFyZ2VVcCA9IGtleSA9PT0gbGFyZ2VTdGVwS2V5c1sxXTtcbiAgICAgICAgICAgIHZhciBpc0Rvd24gPSBrZXkgPT09IHZlcnRpY2FsS2V5c1swXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzBdIHx8IGlzTGFyZ2VEb3duO1xuICAgICAgICAgICAgdmFyIGlzVXAgPSBrZXkgPT09IHZlcnRpY2FsS2V5c1sxXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzFdIHx8IGlzTGFyZ2VVcDtcbiAgICAgICAgICAgIHZhciBpc01pbiA9IGtleSA9PT0gZWRnZUtleXNbMF07XG4gICAgICAgICAgICB2YXIgaXNNYXggPSBrZXkgPT09IGVkZ2VLZXlzWzFdO1xuICAgICAgICAgICAgaWYgKCFpc0Rvd24gJiYgIWlzVXAgJiYgIWlzTWluICYmICFpc01heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciB0bztcbiAgICAgICAgICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHMgPSBnZXROZXh0U3RlcHNGb3JIYW5kbGUoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHN0ZXBzW2RpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVkZ2Ugb2YgYSBzbGlkZXIsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLmdldERlZmF1bHRTdGVwKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCBpc0Rvd24sIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCAqPSBvcHRpb25zLmtleWJvYXJkUGFnZU11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGVwICo9IG9wdGlvbnMua2V5Ym9hcmRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcbiAgICAgICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTtcbiAgICAgICAgICAgICAgICAvLyBEZWNyZW1lbnQgZm9yIGRvd24gc3RlcHNcbiAgICAgICAgICAgICAgICBzdGVwID0gKGlzRG93biA/IC0xIDogMSkgKiBzdGVwO1xuICAgICAgICAgICAgICAgIHRvID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmQga2V5XG4gICAgICAgICAgICAgICAgdG8gPSBvcHRpb25zLnNwZWN0cnVtLnhWYWxbb3B0aW9ucy5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSG9tZSBrZXlcbiAgICAgICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cbiAgICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgb25seSBib3VuZCB0byB0aGUgdmlzdWFsIGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgaGFuZGxlLmNoaWxkcmVuWzBdLCBldmVudFN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgdGFwIGV2ZW50IHRvIHRoZSBzbGlkZXIgYmFzZS5cbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIudGFwKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgc2NvcGVfQmFzZSwgZXZlbnRUYXAsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcmUgaG92ZXIgZXZlbnRzXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmhvdmVyKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9CYXNlLCBldmVudEhvdmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmFuZ2UgZHJhZ2dhYmxlLlxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoY29ubmVjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QgPT09IGZhbHNlIHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUFmdGVyID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEhvbGRlcnMgPSBbY29ubmVjdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVzVG9EcmFnID0gW2hhbmRsZUJlZm9yZSwgaGFuZGxlQWZ0ZXJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyc1RvRHJhZyA9IFtpbmRleCAtIDEsIGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoY29ubmVjdCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWdnYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHJhbmdlIGlzIGZpeGVkLCB0aGUgZW50aXJlIHJhbmdlIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBkcmFnZ2VkIGJ5IHRoZSBoYW5kbGVzLiBUaGUgaGFuZGxlIGluIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IG5lZWRzIHRvIGJlIGJvdW5kIG1hbnVhbGx5IG9uIHRoZSBvdGhlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmRyYWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXNUb0RyYWcgPSBzY29wZV9IYW5kbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyc1RvRHJhZyA9IHNjb3BlX0hhbmRsZU51bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBldmVudEhvbGRlciwgZXZlbnRTdGFydCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IGhhbmRsZXNUb0RyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogaGFuZGxlTnVtYmVyc1RvRHJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBjb25uZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGEsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJbnRlcm5hbE5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLmFyaWEgfHwgbmFtZXNwYWNlID09PSBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcztcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRvIGF0dGFjaG1lbnQgb2YgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuYW1lc3BhY2VkRXZlbnQgJiYgbmFtZXNwYWNlZEV2ZW50LnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBldmVudCA/IG5hbWVzcGFjZWRFdmVudC5zdWJzdHJpbmcoZXZlbnQubGVuZ3RoKSA6IG5hbWVzcGFjZWRFdmVudDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICgoIWV2ZW50IHx8IGV2ZW50ID09PSB0RXZlbnQpICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkZWxldGUgcHJvdGVjdGVkIGludGVybmFsIGV2ZW50IGlmIGludGVudGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbE5hbWVzcGFjZSh0TmFtZXNwYWNlKSB8fCBuYW1lc3BhY2UgPT09IHROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRlcm5hbCBldmVudCBoYW5kbGluZ1xuICAgICAgICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVOdW1iZXIsIHRhcCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGluZGV4LCAwIG9yIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlciwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1mb3JtYXR0ZWQgc2xpZGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgaXMgZmlyZWQgYnkgdGFwLCB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXAgfHwgZmFsc2UsIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBvZmZzZXQgb2YgdGhlIGhhbmRsZSwgaW4gcmVsYXRpb24gdG8gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbGlkZXIgcHVibGljIEFQSSB0byBhbiBhY2Nlc3NpYmxlIHBhcmFtZXRlciB3aGVuIHRoaXMgaXMgdW5hdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1NlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tIYW5kbGVQb3NpdGlvbihyZWZlcmVuY2UsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGdldFZhbHVlLCBzbW9vdGhTdGVwcykge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gRm9yIHNsaWRlcnMgd2l0aCBtdWx0aXBsZSBoYW5kbGVzLCBsaW1pdCBtb3ZlbWVudCB0byB0aGUgb3RoZXIgaGFuZGxlLlxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxuICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSAmJiAhb3B0aW9ucy5ldmVudHMudW5jb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciAtIDFdLCBvcHRpb25zLm1hcmdpbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5tYXJnaW4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXG4gICAgICAgICAgICAvLyBtYXhpbXVtIGRpc3RhbmNlIGZyb20gYW5vdGhlci4gTGltaXQgbXVzdCBiZSA+IDAsIGFzIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gaGFuZGxlcyB3b3VsZCBiZSB1bm1vdmFibGUuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5saW1pdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5saW1pdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgcGFkZGluZyBvcHRpb24ga2VlcHMgdGhlIGhhbmRsZXMgYSBjZXJ0YWluIGRpc3RhbmNlIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKDAsIG9wdGlvbnMucGFkZGluZ1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMTAwLCBvcHRpb25zLnBhZGRpbmdbMV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzbW9vdGhTdGVwcykge1xuICAgICAgICAgICAgICAgIHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaW1pdCBwZXJjZW50YWdlIHRvIHRoZSAwIC0gMTAwIHJhbmdlXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxuICAgICAgICAgICAgaWYgKHRvID09PSByZWZlcmVuY2VbaGFuZGxlTnVtYmVyXSAmJiAhZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlcyBzbGlkZXIgb3JpZW50YXRpb24gdG8gY3JlYXRlIENTUyBydWxlcy4gYSA9IGJhc2UgdmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGluUnVsZU9yZGVyKHYsIGEpIHtcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XG4gICAgICAgICAgICByZXR1cm4gKG8gPyBhIDogdikgKyBcIiwgXCIgKyAobyA/IHYgOiBhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlcyBoYW5kbGUocykgYnkgYSBwZXJjZW50YWdlXG4gICAgICAgIC8vIChib29sLCAlIHRvIG1vdmUsIFslIHdoZXJlIGhhbmRsZSBzdGFydGVkLCAuLi5dLCBbaW5kZXggaW4gc2NvcGVfSGFuZGxlcywgLi4uXSlcbiAgICAgICAgZnVuY3Rpb24gbW92ZUhhbmRsZXModXB3YXJkLCBwcm9wb3NhbCwgbG9jYXRpb25zLCBoYW5kbGVOdW1iZXJzLCBjb25uZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWxzID0gbG9jYXRpb25zLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBTdG9yZSBmaXJzdCBoYW5kbGUgbm93LCBzbyB3ZSBzdGlsbCBoYXZlIGl0IGluIGNhc2UgaGFuZGxlTnVtYmVycyBpcyByZXZlcnNlZFxuICAgICAgICAgICAgdmFyIGZpcnN0SGFuZGxlID0gaGFuZGxlTnVtYmVyc1swXTtcbiAgICAgICAgICAgIHZhciBzbW9vdGhTdGVwcyA9IG9wdGlvbnMuZXZlbnRzLnNtb290aFN0ZXBzO1xuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcbiAgICAgICAgICAgIHZhciBmID0gW3Vwd2FyZCwgIXVwd2FyZF07XG4gICAgICAgICAgICAvLyBDb3B5IGhhbmRsZU51bWJlcnMgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBkYXRhc2V0XG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzID0gaGFuZGxlTnVtYmVycy5zbGljZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIHdoaWNoIGhhbmRsZSBpcyAnbGVhZGluZycuXG4gICAgICAgICAgICAvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxuICAgICAgICAgICAgaWYgKHVwd2FyZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0byA9IGNoZWNrSGFuZGxlUG9zaXRpb24ocHJvcG9zYWxzLCBoYW5kbGVOdW1iZXIsIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsIGJbb10sIGZbb10sIGZhbHNlLCBzbW9vdGhTdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgb25lIG9mIHRoZSBoYW5kbGVzIGNhbid0IG1vdmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gdG8gLSBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gZiA9IFt0cnVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyLCBvKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dLCBmYWxzZSwgc21vb3RoU3RlcHMpIHx8IHN0YXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTdGVwIDM6IElmIGEgaGFuZGxlIG1vdmVkLCBmaXJlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGFyZ2V0IGlzIGEgY29ubmVjdCwgdGhlbiBmaXJlIGRyYWcgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiZHJhZ1wiLCBmaXJzdEhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRha2VzIGEgYmFzZSB2YWx1ZSBhbmQgYW4gb2Zmc2V0LiBUaGlzIG9mZnNldCBpcyB1c2VkIGZvciB0aGUgY29ubmVjdCBiYXIgc2l6ZS5cbiAgICAgICAgLy8gSW4gdGhlIGluaXRpYWwgZGVzaWduIGZvciB0aGlzIGZlYXR1cmUsIHRoZSBvcmlnaW4gZWxlbWVudCB3YXMgMSUgd2lkZS5cbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgYSByb3VuZGluZyBidWcgaW4gQ2hyb21lIG1ha2VzIGl0IGltcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZmVhdHVyZVxuICAgICAgICAvLyBpbiB0aGlzIG1hbm5lcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Nzk4MjIzXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybURpcmVjdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBhIC0gYiA6IGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0bykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2F0aW9ucy5cbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgc2xpZGVyIHN0ZXBwaW5nL3JhbmdlLlxuICAgICAgICAgICAgc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcodG8pO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldDtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2xhdGlvbiArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID0gdHJhbnNsYXRlUnVsZTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlcyBiZWZvcmUgdGhlIHNsaWRlciBtaWRkbGUgYXJlIHN0YWNrZWQgbGF0ZXIgPSBoaWdoZXIsXG4gICAgICAgIC8vIEhhbmRsZXMgYWZ0ZXIgdGhlIG1pZGRsZSBsYXRlciBpcyBsb3dlclxuICAgICAgICAvLyBbWzddIFs4XSAuLi4uLi4uLi4uIHwgLi4uLi4uLi4uLiBbNV0gWzRdXG4gICAgICAgIGZ1bmN0aW9uIHNldFppbmRleCgpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID4gNTAgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIHpJbmRleCA9IDMgKyAoc2NvcGVfSGFuZGxlcy5sZW5ndGggKyBkaXIgKiBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoekluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3Qgc3VnZ2VzdGVkIHZhbHVlcyBhbmQgYXBwbHkgbWFyZ2luLCBzdGVwLlxuICAgICAgICAvLyBpZiBleGFjdElucHV0IGlzIHRydWUsIGRvbid0IHJ1biBjaGVja0hhbmRsZVBvc2l0aW9uLCB0aGVuIHRoZSBoYW5kbGUgY2FuIGJlIHBsYWNlZCBpbiBiZXR3ZWVuIHN0ZXBzICgjNDM2KVxuICAgICAgICBmdW5jdGlvbiBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCB0bywgbG9va0JhY2t3YXJkLCBsb29rRm9yd2FyZCwgZXhhY3RJbnB1dCwgc21vb3RoU3RlcHMpIHtcbiAgICAgICAgICAgIGlmICghZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGZhbHNlLCBzbW9vdGhTdGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGVzIHN0eWxlIGF0dHJpYnV0ZSBmb3IgY29ubmVjdCBub2Rlc1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb25uZWN0KGluZGV4KSB7XG4gICAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgaWYgKCFzY29wZV9Db25uZWN0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgICAgICB2YXIgaCA9IDEwMDtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGwgPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGggPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgdXNlIHR3byBydWxlczpcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xuICAgICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gQXMgdGhlIGVsZW1lbnQgaGFzIGEgd2lkdGggb2YgMTAwJSwgYSB0cmFuc2xhdGlvbiBvZiAxMDAlIGlzIGVxdWFsIHRvIDEwMCUgb2YgdGhlIHBhcmVudCAoLm5vVWktYmFzZSlcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2Zvcm1EaXJlY3Rpb24obCwgY29ubmVjdFdpZHRoKSArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBzY2FsZVJ1bGUgPSBcInNjYWxlKFwiICsgaW5SdWxlT3JkZXIoY29ubmVjdFdpZHRoIC8gMTAwLCBcIjFcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVSdWxlICsgXCIgXCIgKyBzY2FsZVJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2VzIHZhbHVlIHBhc3NlZCB0byAuc2V0IG1ldGhvZC4gUmV0dXJucyBjdXJyZW50IHZhbHVlIGlmIG5vdCBwYXJzZS1hYmxlLlxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlVG9WYWx1ZSh0bywgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXG4gICAgICAgICAgICAvLyBJbnB1dHRpbmcgJ2ZhbHNlJyBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBmb3JtYXR0ZWQgbnVtYmVyIHdhcyBwYXNzZWQsIGF0dGVtcHQgdG8gZGVjb2RlIGl0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRvID0gU3RyaW5nKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG4gICAgICAgICAgICBpZiAodG8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgdGhlIG51bWJlciBmYWlsZWQsIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNOYU4odG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldChpbnB1dCwgZmlyZVNldEV2ZW50LCBleGFjdElucHV0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XG4gICAgICAgICAgICB2YXIgaXNJbml0ID0gc2NvcGVfTG9jYXRpb25zWzBdID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBFdmVudCBmaXJlcyBieSBkZWZhdWx0XG4gICAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmaXJlU2V0RXZlbnQ7XG4gICAgICAgICAgICAvLyBBbmltYXRpb24gaXMgb3B0aW9uYWwuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluaXRpYWwgdmFsdWVzIHdlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcGFzcywgd2l0aG91dCBsb29rQWhlYWQgYnV0IHdpdGggbG9va0JhY2t3YXJkLiBWYWx1ZXMgYXJlIHNldCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpID0gc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPT09IDEgPyAwIDogMTtcbiAgICAgICAgICAgIC8vIFNwcmVhZCBoYW5kbGVzIGV2ZW5seSBhY3Jvc3MgdGhlIHNsaWRlciBpZiB0aGUgcmFuZ2UgaGFzIG5vIHNpemUgKG1pbj1tYXgpXG4gICAgICAgICAgICBpZiAoaXNJbml0ICYmIHNjb3BlX1NwZWN0cnVtLmhhc05vU2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgZXhhY3RJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zWzBdID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZV8xID0gMTAwIC8gKHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA9IGhhbmRsZU51bWJlciAqIHNwYWNlXzE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBwYXNzZXMuIE5vdyB0aGF0IGFsbCBiYXNlIHZhbHVlcyBhcmUgc2V0LCBhcHBseSBjb25zdHJhaW50cy5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgYWxsIGhhbmRsZXMgdG8gZW5zdXJlIGNvbnN0cmFpbnRzIGFyZSBhcHBsaWVkIGZvciB0aGUgZW50aXJlIHNsaWRlciAoSXNzdWUgIzEwMDkpXG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaGFuZGxlTnVtYmVyXSAhPT0gbnVsbCAmJiBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgc2xpZGVyIHRvIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlUmVzZXQoZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCwgZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG51bWVyaWMgaW5wdXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKCEoaGFuZGxlTnVtYmVyID49IDAgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogaW52YWxpZCBoYW5kbGUgbnVtYmVyLCBnb3Q6IFwiICsgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2sgYm90aCBiYWNrd2FyZCBhbmQgZm9yd2FyZCwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGhhbmRsZSB0byBcInB1c2hcIiBvdGhlciBoYW5kbGVzICgjOTYwKTtcbiAgICAgICAgICAgIC8vIFRoZSBleGFjdElucHV0IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGlnbm9yZSBzbGlkZXIgc3RlcHBpbmcgKCM0MzYpXG4gICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVHZXQodW5lbmNvZGVkKSB7XG4gICAgICAgICAgICBpZiAodW5lbmNvZGVkID09PSB2b2lkIDApIHsgdW5lbmNvZGVkID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICh1bmVuY29kZWQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSByYXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1ZhbHVlcy5sZW5ndGggPT09IDEgPyBzY29wZV9WYWx1ZXNbMF0gOiBzY29wZV9WYWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byk7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgcm9vdCBhbmQgZW1wdGllcyBpdC5cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgbGlzdGVuZXJzXG4gICAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuY3NzQ2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdoaWxlIChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgc2NvcGVfVGFyZ2V0Lm5vVWlTbGlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyhsb2NhdGlvbik7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xuICAgICAgICAgICAgdmFyIGRlY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiBzbmFwcGVkLCBkaXJlY3RseSB1c2UgZGVmaW5lZCBzdGVwIHZhbHVlXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0YXJ0VmFsdWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCB2YWx1ZSBpbiB0aGlzIHN0ZXAgbW92ZXMgaW50byB0aGUgbmV4dCBzdGVwLFxuICAgICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSArIGluY3JlbWVudCA+IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGJleW9uZCB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGVwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBoYW5kbGUgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgc3RlcCwgaXQgYWx3YXlzIHN0ZXBzIGJhY2sgaW50byB0aGUgcHJldmlvdXMgc3RlcCBmaXJzdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLmhpZ2hlc3RTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93LCBpZiBhdCB0aGUgc2xpZGVyIGVkZ2VzLCB0aGVyZSBpcyBubyBpbi9kZWNyZW1lbnRcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvY2F0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxuICAgICAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHNjb3BlX1NwZWN0cnVtLmNvdW50U3RlcERlY2ltYWxzKCk7XG4gICAgICAgICAgICAvLyBSb3VuZCBwZXIgIzM5MVxuICAgICAgICAgICAgaWYgKGluY3JlbWVudCAhPT0gbnVsbCAmJiBpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gTnVtYmVyKGluY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gTnVtYmVyKGRlY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtkZWNyZW1lbnQsIGluY3JlbWVudF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFN0ZXBzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0hhbmRsZU51bWJlcnMubWFwKGdldE5leHRTdGVwc0ZvckhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRhYmxlOiBtYXJnaW4sIGxpbWl0LCBwYWRkaW5nLCBzdGVwLCByYW5nZSwgYW5pbWF0ZSwgc25hcFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdGlvbnNUb1VwZGF0ZSwgZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBTcGVjdHJ1bSBpcyBjcmVhdGVkIHVzaW5nIHRoZSByYW5nZSwgc25hcCwgZGlyZWN0aW9uIGFuZCBzdGVwIG9wdGlvbnMuXG4gICAgICAgICAgICAvLyAnc25hcCcgYW5kICdzdGVwJyBjYW4gYmUgdXBkYXRlZC5cbiAgICAgICAgICAgIC8vIElmICdzbmFwJyBhbmQgJ3N0ZXAnIGFyZSBub3QgcGFzc2VkLCB0aGV5IHNob3VsZCByZW1haW4gdW5jaGFuZ2VkLlxuICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZUdldCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZUFibGUgPSBbXG4gICAgICAgICAgICAgICAgXCJtYXJnaW5cIixcbiAgICAgICAgICAgICAgICBcImxpbWl0XCIsXG4gICAgICAgICAgICAgICAgXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiLFxuICAgICAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICAgICAgICAgIFwic25hcFwiLFxuICAgICAgICAgICAgICAgIFwic3RlcFwiLFxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgXCJwaXBzXCIsXG4gICAgICAgICAgICAgICAgXCJ0b29sdGlwc1wiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIE9ubHkgY2hhbmdlIG9wdGlvbnMgdGhhdCB3ZSdyZSBhY3R1YWxseSBwYXNzZWQgdG8gdXBkYXRlLlxuICAgICAgICAgICAgdXBkYXRlQWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVuZGVmaW5lZC4gbnVsbCByZW1vdmVzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB0ZXN0T3B0aW9ucyhvcmlnaW5hbE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gTG9hZCBuZXcgb3B0aW9ucyBpbnRvIHRoZSBzbGlkZXIgc3RhdGVcbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gbmV3T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjb3BlX1NwZWN0cnVtID0gbmV3T3B0aW9ucy5zcGVjdHJ1bTtcbiAgICAgICAgICAgIC8vIExpbWl0LCBtYXJnaW4gYW5kIHBhZGRpbmcgZGVwZW5kIG9uIHRoZSBzcGVjdHJ1bSBidXQgYXJlIHN0b3JlZCBvdXRzaWRlIG9mIGl0LiAoIzY3NylcbiAgICAgICAgICAgIG9wdGlvbnMubWFyZ2luID0gbmV3T3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0ID0gbmV3T3B0aW9ucy5saW1pdDtcbiAgICAgICAgICAgIG9wdGlvbnMucGFkZGluZyA9IG5ld09wdGlvbnMucGFkZGluZztcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwaXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVBpcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0b29sdGlwcywgcmVtb3ZlcyBleGlzdGluZy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIHNvIHZhbHVlU2V0IGZvcmNlcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlU2V0KGlzU2V0KG9wdGlvbnNUb1VwZGF0ZS5zdGFydCkgPyBvcHRpb25zVG9VcGRhdGUuc3RhcnQgOiB2LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIHN0ZXBzXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwU2xpZGVyKCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNlIGVsZW1lbnQsIGluaXRpYWxpemUgSFRNTCBhbmQgc2V0IGNsYXNzZXMuXG4gICAgICAgICAgICAvLyBBZGQgaGFuZGxlcyBhbmQgY29ubmVjdCBlbGVtZW50cy5cbiAgICAgICAgICAgIHNjb3BlX0Jhc2UgPSBhZGRTbGlkZXIoc2NvcGVfVGFyZ2V0KTtcbiAgICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7XG4gICAgICAgICAgICAvLyBBdHRhY2ggdXNlciBldmVudHMuXG4gICAgICAgICAgICBiaW5kU2xpZGVyRXZlbnRzKG9wdGlvbnMuZXZlbnRzKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHVibGljIHZhbHVlIG1ldGhvZCB0byBzZXQgdGhlIHN0YXJ0IHZhbHVlcy5cbiAgICAgICAgICAgIHZhbHVlU2V0KG9wdGlvbnMuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyaWEoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR1cFNsaWRlcigpO1xuICAgICAgICB2YXIgc2NvcGVfU2VsZiA9IHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICBzdGVwczogZ2V0TmV4dFN0ZXBzLFxuICAgICAgICAgICAgb246IGJpbmRFdmVudCxcbiAgICAgICAgICAgIG9mZjogcmVtb3ZlRXZlbnQsXG4gICAgICAgICAgICBnZXQ6IHZhbHVlR2V0LFxuICAgICAgICAgICAgc2V0OiB2YWx1ZVNldCxcbiAgICAgICAgICAgIHNldEhhbmRsZTogdmFsdWVTZXRIYW5kbGUsXG4gICAgICAgICAgICByZXNldDogdmFsdWVSZXNldCxcbiAgICAgICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIF9fbW92ZUhhbmRsZXM6IGZ1bmN0aW9uICh1cHdhcmQsIHByb3Bvc2FsLCBoYW5kbGVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZXModXB3YXJkLCBwcm9wb3NhbCwgc2NvcGVfTG9jYXRpb25zLCBoYW5kbGVOdW1iZXJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsXG4gICAgICAgICAgICB1cGRhdGVPcHRpb25zOiB1cGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgdGFyZ2V0OiBzY29wZV9UYXJnZXQsXG4gICAgICAgICAgICByZW1vdmVQaXBzOiByZW1vdmVQaXBzLFxuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxuICAgICAgICAgICAgZ2V0UG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRvb2x0aXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1Rvb2x0aXBzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE9yaWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfSGFuZGxlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaXBzOiBwaXBzLCAvLyBJc3N1ZSAjNTk0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzY29wZV9TZWxmO1xuICAgIH1cbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSh0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKHRhcmdldC5ub1VpU2xpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH1cbiAgICB2YXIgbm91aXNsaWRlciA9IHtcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICBfX3NwZWN0cnVtOiBTcGVjdHJ1bSxcbiAgICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgY2xhc3NlcywgYWxsb3dzIGdsb2JhbCBjaGFuZ2VzLlxuICAgICAgICAvLyBVc2UgdGhlIGNzc0NsYXNzZXMgb3B0aW9uIGZvciBjaGFuZ2VzIHRvIG9uZSBzbGlkZXIuXG4gICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgIGNyZWF0ZTogaW5pdGlhbGl6ZSxcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5jcmVhdGUgPSBpbml0aWFsaXplO1xuICAgIGV4cG9ydHMuY3NzQ2xhc3NlcyA9IGNzc0NsYXNzZXM7XG4gICAgZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBub3Vpc2xpZGVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nouislider/dist/nouislider.js\n");

/***/ }),

/***/ "./src/icons/icons.js":
/*!****************************!*\
  !*** ./src/icons/icons.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _svg_arrow_up_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg/arrow-up.svg */ \"./src/icons/svg/arrow-up.svg\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaWNvbnMvaWNvbnMuanM/NTMzNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwiZmlsZSI6Ii4vc3JjL2ljb25zL2ljb25zLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi9zdmcvYXJyb3ctdXAuc3ZnXCI7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/icons/icons.js\n");

/***/ }),

/***/ "./src/icons/svg/arrow-up.svg":
/*!************************************!*\
  !*** ./src/icons/svg/arrow-up.svg ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n      id: \"icon-arrow-up-usage\",\n      viewBox: \"0 0 8 4\",\n      url: __webpack_require__.p + \"./images/icons/sprite.svg#icon-arrow-up\",\n      toString: function () {\n        return this.url;\n      }\n    });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaWNvbnMvc3ZnL2Fycm93LXVwLnN2Zz8xOTdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVyxxQkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSyIsImZpbGUiOiIuL3NyYy9pY29ucy9zdmcvYXJyb3ctdXAuc3ZnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICAgICAgaWQ6IFwiaWNvbi1hcnJvdy11cC11c2FnZVwiLFxuICAgICAgdmlld0JveDogXCIwIDAgOCA0XCIsXG4gICAgICB1cmw6IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIuL2ltYWdlcy9pY29ucy9zcHJpdGUuc3ZnI2ljb24tYXJyb3ctdXBcIixcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICAgIH1cbiAgICB9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/icons/svg/arrow-up.svg\n");

/***/ }),

/***/ "./src/js/script.js":
/*!**************************!*\
  !*** ./src/js/script.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nouislider */ \"./node_modules/nouislider/dist/nouislider.js\");\n/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nouislider__WEBPACK_IMPORTED_MODULE_0__);\n\nvar costSlider = document.getElementById(\"slider-cost\");\nvar from = 1000000;\nvar to = 2000000;\nnouislider__WEBPACK_IMPORTED_MODULE_0___default.a.create(costSlider, {\n  start: [(from + to) / 2 - 250000, (from + to) / 2 + 250000],\n  connect: true,\n  step: 15000,\n  range: {\n    min: from,\n    max: to\n  }\n});\nvar inputNumber = document.getElementById(\"cost-to\");\nvar inputNumber2 = document.getElementById(\"cost-from\");\ncostSlider.noUiSlider.on(\"update\", function (values, handle) {\n  var value = values[handle];\n\n  if (handle) {\n    inputNumber.value = value.split(\".\")[0].replace(/[^0-9.]/g, \"\").replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n    console.log(\"right\");\n  } else {\n    inputNumber2.value = value.split(\".\")[0].replace(/[^0-9.]/g, \"\").replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n    console.log(\"left\");\n  }\n});\ninputNumber.addEventListener(\"change\", function () {\n  costSlider.noUiSlider.set([null, this.value]);\n  console.log(\"ok1\");\n});\ninputNumber2.addEventListener(\"change\", function () {\n  costSlider.noUiSlider.set([this.value, null]);\n  console.log(\"ok2\");\n}); //==============================================================\n\nvar squareSlider = document.getElementById(\"slider-square\");\nvar from1 = 20;\nvar to1 = 150;\nnouislider__WEBPACK_IMPORTED_MODULE_0___default.a.create(squareSlider, {\n  start: [(from1 + to1) / 2 - 10, (from1 + to1) / 2 + 10],\n  connect: true,\n  step: 1,\n  range: {\n    min: from1,\n    max: to1\n  }\n});\nvar inputNumber3 = document.getElementById(\"square-to\");\nvar inputNumber4 = document.getElementById(\"square-from\");\nsquareSlider.noUiSlider.on(\"update\", function (values, handle) {\n  var value = values[handle];\n\n  if (handle) {\n    inputNumber3.value = value.split(\".\")[0].replace(/[^0-9.]/g, \"\").replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n    console.log(\"right\");\n  } else {\n    inputNumber4.value = value.split(\".\")[0].replace(/[^0-9.]/g, \"\").replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n    console.log(\"left\");\n  }\n});\ninputNumber3.addEventListener(\"change\", function () {\n  squareSlider.noUiSlider.set([null, this.value]);\n  console.log(\"ok1\");\n});\ninputNumber4.addEventListener(\"change\", function () {\n  squareSlider.noUiSlider.set([this.value, null]);\n  console.log(\"ok2\");\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvc2NyaXB0LmpzPzQ0YWQiXSwibmFtZXMiOlsiY29zdFNsaWRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJmcm9tIiwidG8iLCJub1VpU2xpZGVyIiwiY3JlYXRlIiwic3RhcnQiLCJjb25uZWN0Iiwic3RlcCIsInJhbmdlIiwibWluIiwibWF4IiwiaW5wdXROdW1iZXIiLCJpbnB1dE51bWJlcjIiLCJvbiIsInZhbHVlcyIsImhhbmRsZSIsInZhbHVlIiwic3BsaXQiLCJyZXBsYWNlIiwiY29uc29sZSIsImxvZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXQiLCJzcXVhcmVTbGlkZXIiLCJmcm9tMSIsInRvMSIsImlucHV0TnVtYmVyMyIsImlucHV0TnVtYmVyNCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQSxJQUFJQSxVQUFVLEdBQUdDLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixhQUF4QixDQUFqQjtBQUNBLElBQU1DLElBQUksR0FBRyxPQUFiO0FBQ0EsSUFBTUMsRUFBRSxHQUFHLE9BQVg7QUFFQUMsaURBQVUsQ0FBQ0MsTUFBWCxDQUFrQk4sVUFBbEIsRUFBOEI7RUFDNUJPLEtBQUssRUFBRSxDQUFDLENBQUNKLElBQUksR0FBR0MsRUFBUixJQUFjLENBQWQsR0FBa0IsTUFBbkIsRUFBMkIsQ0FBQ0QsSUFBSSxHQUFHQyxFQUFSLElBQWMsQ0FBZCxHQUFrQixNQUE3QyxDQURxQjtFQUU1QkksT0FBTyxFQUFFLElBRm1CO0VBRzVCQyxJQUFJLEVBQUUsS0FIc0I7RUFJNUJDLEtBQUssRUFBRTtJQUNMQyxHQUFHLEVBQUVSLElBREE7SUFFTFMsR0FBRyxFQUFFUjtFQUZBO0FBSnFCLENBQTlCO0FBVUEsSUFBSVMsV0FBVyxHQUFHWixRQUFRLENBQUNDLGNBQVQsQ0FBd0IsU0FBeEIsQ0FBbEI7QUFDQSxJQUFJWSxZQUFZLEdBQUdiLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixXQUF4QixD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QUZrQixDQUVWLFVBRlUsRUFFRSxFQUZGLEVBR2xCQSxPQUhrQixDQUdWLHVCQUhVLEVBR2UsR0FIZixDQUFyQjtJQUlBQyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxNQUFaO0VBQ0Q7QUFDRixDQWhCRDtBQWtCQU0sWUFBWSxDQUFDTCxnQkFBYixDQUE4QixRQUE5QixFQUF3QyxZQUFZO0VBQ2xERSxZQUFZLENBQUNwQixVQUFiLENBQXdCbUIsR0FBeEIsQ0FBNEIsQ0FBQyxJQUFELEVBQU8sS0FBS04sS0FBWixDQUE1QjtFQUNBRyxPQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFaO0FBQ0QsQ0FIRDtBQUtBTyxZQUFZLENBQUNOLGdCQUFiLENBQThCLFFBQTlCLEVBQXdDLFlBQVk7RUFDbERFLFlBQVksQ0FBQ3BCLFVBQWIsQ0FBd0JtQixHQUF4QixDQUE0QixDQUFDLEtBQUtOLEtBQU4sRUFBYSxJQUFiLENBQTVCO0VBQ0FHLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQVo7QUFDRCxDQUhEIiwiZmlsZSI6Ii4vc3JjL2pzL3NjcmlwdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBub1VpU2xpZGVyIGZyb20gXCJub3Vpc2xpZGVyXCI7XHJcblxyXG52YXIgY29zdFNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2xpZGVyLWNvc3RcIik7XHJcbmNvbnN0IGZyb20gPSAxMDAwMDAwO1xyXG5jb25zdCB0byA9IDIwMDAwMDA7XHJcblxyXG5ub1VpU2xpZGVyLmNyZWF0ZShjb3N0U2xpZGVyLCB7XHJcbiAgc3RhcnQ6IFsoZnJvbSArIHRvKSAvIDIgLSAyNTAwMDAsIChmcm9tICsgdG8pIC8gMiArIDI1MDAwMF0sXHJcbiAgY29ubmVjdDogdHJ1ZSxcclxuICBzdGVwOiAxNTAwMCxcclxuICByYW5nZToge1xyXG4gICAgbWluOiBmcm9tLFxyXG4gICAgbWF4OiB0byxcclxuICB9LFxyXG59KTtcclxuXHJcbnZhciBpbnB1dE51bWJlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29zdC10b1wiKTtcclxudmFyIGlucHV0TnVtYmVyMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29zdC1mcm9tXCIpO1xyXG5cclxuY29zdFNsaWRlci5ub1VpU2xpZGVyLm9uKFwidXBkYXRlXCIsIGZ1bmN0aW9uICh2YWx1ZXMsIGhhbmRsZSkge1xyXG4gIHZhciB2YWx1ZSA9IHZhbHVlc1toYW5kbGVdO1xyXG5cclxuICBpZiAoaGFuZGxlKSB7XHJcbiAgICBpbnB1dE51bWJlci52YWx1ZSA9IHZhbHVlXHJcbiAgICAgIC5zcGxpdChcIi5cIilbMF1cclxuICAgICAgLnJlcGxhY2UoL1teMC05Ll0vZywgXCJcIilcclxuICAgICAgLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiIFwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwicmlnaHRcIik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlucHV0TnVtYmVyMi52YWx1ZSA9IHZhbHVlXHJcbiAgICAgIC5zcGxpdChcIi5cIilbMF1cclxuICAgICAgLnJlcGxhY2UoL1teMC05Ll0vZywgXCJcIilcclxuICAgICAgLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiIFwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwibGVmdFwiKTtcclxuICB9XHJcbn0pO1xyXG5cclxuaW5wdXROdW1iZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgY29zdFNsaWRlci5ub1VpU2xpZGVyLnNldChbbnVsbCwgdGhpcy52YWx1ZV0pO1xyXG4gIGNvbnNvbGUubG9nKFwib2sxXCIpO1xyXG59KTtcclxuXHJcbmlucHV0TnVtYmVyMi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcclxuICBjb3N0U2xpZGVyLm5vVWlTbGlkZXIuc2V0KFt0aGlzLnZhbHVlLCBudWxsXSk7XHJcbiAgY29uc29sZS5sb2coXCJvazJcIik7XHJcbn0pO1xyXG5cclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxudmFyIHNxdWFyZVNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2xpZGVyLXNxdWFyZVwiKTtcclxuY29uc3QgZnJvbTEgPSAyMDtcclxuY29uc3QgdG8xID0gMTUwO1xyXG5cclxubm9VaVNsaWRlci5jcmVhdGUoc3F1YXJlU2xpZGVyLCB7XHJcbiAgc3RhcnQ6IFsoZnJvbTEgKyB0bzEpIC8gMiAtIDEwLCAoZnJvbTEgKyB0bzEpIC8gMiArIDEwXSxcclxuICBjb25uZWN0OiB0cnVlLFxyXG4gIHN0ZXA6IDEsXHJcbiAgcmFuZ2U6IHtcclxuICAgIG1pbjogZnJvbTEsXHJcbiAgICBtYXg6IHRvMSxcclxuICB9LFxyXG59KTtcclxuXHJcbnZhciBpbnB1dE51bWJlcjMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNxdWFyZS10b1wiKTtcclxudmFyIGlucHV0TnVtYmVyNCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3F1YXJlLWZyb21cIik7XHJcblxyXG5zcXVhcmVTbGlkZXIubm9VaVNsaWRlci5vbihcInVwZGF0ZVwiLCBmdW5jdGlvbiAodmFsdWVzLCBoYW5kbGUpIHtcclxuICB2YXIgdmFsdWUgPSB2YWx1ZXNbaGFuZGxlXTtcclxuXHJcbiAgaWYgKGhhbmRsZSkge1xyXG4gICAgaW5wdXROdW1iZXIzLnZhbHVlID0gdmFsdWVcclxuICAgICAgLnNwbGl0KFwiLlwiKVswXVxyXG4gICAgICAucmVwbGFjZSgvW14wLTkuXS9nLCBcIlwiKVxyXG4gICAgICAucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIgXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJyaWdodFwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaW5wdXROdW1iZXI0LnZhbHVlID0gdmFsdWVcclxuICAgICAgLnNwbGl0KFwiLlwiKVswXVxyXG4gICAgICAucmVwbGFjZSgvW14wLTkuXS9nLCBcIlwiKVxyXG4gICAgICAucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIgXCIpO1xyXG4gICAgY29uc29sZS5sb2coXCJsZWZ0XCIpO1xyXG4gIH1cclxufSk7XHJcblxyXG5pbnB1dE51bWJlcjMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgc3F1YXJlU2xpZGVyLm5vVWlTbGlkZXIuc2V0KFtudWxsLCB0aGlzLnZhbHVlXSk7XHJcbiAgY29uc29sZS5sb2coXCJvazFcIik7XHJcbn0pO1xyXG5cclxuaW5wdXROdW1iZXI0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xyXG4gIHNxdWFyZVNsaWRlci5ub1VpU2xpZGVyLnNldChbdGhpcy52YWx1ZSwgbnVsbF0pO1xyXG4gIGNvbnNvbGUubG9nKFwib2syXCIpO1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/script.js\n");

/***/ }),

/***/ "./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9zdHlsZS5zY3NzP2QxYzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvc2Nzcy9zdHlsZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scss/style.scss\n");

/***/ }),

/***/ 0:
/*!***************************************************************************!*\
  !*** multi ./src/js/script.js ./src/scss/style.scss ./src/icons/icons.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./src/js/script.js */"./src/js/script.js");
__webpack_require__(/*! ./src/scss/style.scss */"./src/scss/style.scss");
module.exports = __webpack_require__(/*! ./src/icons/icons.js */"./src/icons/icons.js");


/***/ })

/******/ });